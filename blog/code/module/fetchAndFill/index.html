<!DOCTYPE html>
<html lang="id">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="Fetch & Fill untuk Single Page Application (SPA) dengan caching, sanitasi, event custom, dan validasi ketat. Solusi aman dan efisien untuk konten dinamis.">
		<meta name="keywords" content="SPA, fetch, fill, DOMPurify, caching, sanitasi, custom events, JavaScript, dinamis, konten, Fetch & Fill">
		<meta name="author" content="Mbah Babat">
		<meta name="robots" content="index, follow">
		<meta name="revisit-after" content="7 days">
		<meta name="language" content="Indonesian">
		<meta name="geo.region" content="ID">
		<meta name="geo.placename" content="Indonesia">
		<meta name="distribution" content="Global">
		<meta name="rating" content="General">
		<meta name="theme-color" content="#4361ee">
		<!-- Open Graph untuk share di media sosial -->
		<meta property="og:title" content="Fetch & Fill untuk Single Page Application (SPA)">
		<meta property="og:description" content="Fetch & Fill untuk Single Page Application (SPA) dengan caching, sanitasi, event custom, dan validasi ketat. Solusi aman dan efisien untuk konten dinamis.">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://mbahbabat.github.io/spa">
		<meta property="og:image" content="https://mbahbabat.github.io/spa/spa.png">
		<meta property="og:site_name" content="Gmooy">
		<meta property="og:locale" content="id_ID">
		<!-- Twitter Card -->
		<meta name="twitter:card" content="summary_large_image">
		<meta name="twitter:title" content="Fetch & Fill untuk Single Page Application (SPA)">
		<meta name="twitter:description" content="Fetch & Fill untuk Single Page Application (SPA) dengan caching, sanitasi, event custom, dan validasi ketat. Solusi aman dan efisien untuk konten dinamis.">
		<meta name="twitter:image" content="https://mbahbabat.github.io/spa/spa.png">
		<meta name="twitter:site" content="@gmooy_id">
		<meta name="twitter:creator" content="@mbah_babat">
		<title>Fetch & Fill untuk Single Page Application (SPA)</title>
		<!-- Canonical URL -->
		<link rel="canonical" href="https://mbahbabat.github.io/spa/">
		<link rel="shortcut icon" href="https://mbahbabat.github.io/spa/spa.png">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.5/purify.min.js"></script>
		<style>
			:root {
				--primary: #4361ee;
				--secondary: #3f37c9;
				--accent: #4895ef;
				--success: #4cc9f0;
				--danger: #f72585;
				--warning: #ff9e00;
				--light: #f8f9fa;
				--dark: #212529;
				--gray: #6c757d;
				--bg-gradient: linear-gradient(135deg, #f5f7fa 0, #e4edf5 100%)
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0
			}

			body {
				font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
				line-height: 1.6;
				color: #333;
				background: var(--bg-gradient);
				min-height: 100vh;
				padding: 20px
			}

			.container {
				max-width: 1400px;
				margin: 0 auto
			}

			header {
				background: var(--primary);
				color: white;
				padding: 2rem;
				border-radius: 15px;
				box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
				margin-bottom: 2rem;
				text-align: center;
				position: relative;
				overflow: hidden
			}

			header::before {
				content: "";
				position: absolute;
				top: -50%;
				left: -50%;
				width: 200%;
				height: 200%;
				background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0, rgba(255, 255, 255, 0) 70%);
				pointer-events: none
			}

			h1 {
				font-size: 3rem;
				margin-bottom: 1rem;
				text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2)
			}

			.subtitle {
				font-size: 1.4rem;
				opacity: .9;
				max-width: 900px;
				margin: 0 auto 1.5rem
			}
			
			.badge-features{
				display: flex;
				justify-content: center;
			}

			.badge {
				display: inline-block;
				background: var(--accent);
				color: white;
				padding: 5px 15px;
				border-radius: 20px;
				font-size: 1rem;
				font-weight: bold;
				margin: 0 5px;
				vertical-align: middle;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1)
			}

			.dashboard {
				display: grid;
				grid-template-columns: 300px 1fr;
				gap: 25px;
				margin-bottom: 2rem
			}

			.card {
				background: white;
				border-radius: 15px;
				padding: 2rem;
				box-shadow: 0 6px 15px rgba(0, 0, 0, 0.08);
				margin-bottom: 2rem;
				transition: transform .3s ease, box-shadow .3s ease
			}

			.card:hover {
				transform: translateY(-5px);
				box-shadow: 0 12px 20px rgba(0, 0, 0, 0.12)
			}

			.card-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 1.5rem;
				padding-bottom: 1rem;
				border-bottom: 2px solid var(--accent)
			}

			.card h2 {
				color: var(--primary);
				font-size: 1.8rem
			}

			.icon-large {
				font-size: 2.5rem;
				color: var(--accent)
			}

			.features-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
				gap: 20px;
				margin-top: 1.5rem
			}

			.feature {
				display: flex;
				align-items: flex-start;
				gap: 15px;
				padding: 15px;
				background: rgba(72, 149, 239, 0.05);
				border-radius: 10px;
				transition: all .3s ease
			}

			.feature:hover {
				background: rgba(72, 149, 239, 0.1);
				transform: translateX(5px)
			}

			.feature i {
				font-size: 1.8rem;
				color: var(--accent);
				min-width: 40px
			}

			.feature h3 {
				margin-bottom: 8px;
				color: var(--dark)
			}

			.tabs {
				display: flex;
				gap: 10px;
				margin: 1.5rem 0;
				flex-wrap: wrap
			}

			.tab {
				padding: 12px 25px;
				background: rgba(67, 97, 238, 0.1);
				border-radius: 8px;
				cursor: pointer;
				transition: all .3s ease;
				font-weight: 500
			}

			.tab.active {
				background: var(--primary);
				color: white
			}

			.tab:hover:not(.active) {
				background: rgba(67, 97, 238, 0.2)
			}

			.tab-content {
				display: none
			}

			.tab-content.active {
				display: block
			}

			.code-block {
				background: var(--bg-gradient);
				padding: 25px;
				border-radius: 10px;
				font-family: 'Fira Code', monospace;
				overflow-x: auto;
				margin: 20px 0;
				font-size: .95rem;
				position: relative
			}

			.code-header {
				display: flex;
				justify-content: space-between;
				margin-bottom: 15px;
				color: #000
			}

			.actions-btn {
				display: flex;
				gap: 10px
			}

			.copy-btn,
			.open-btn,
			.download-btn {
				background: rgba(255, 255, 255, 0.1);
				border: 0;
				color: var(--gray);
				padding: 5px 15px;
				border-radius: 5px;
				cursor: pointer;
				transition: all .3s ease
			}

			.copy-btn:hover,
			.open-btn:hover,
			.download-btn:hover {
				background: rgba(255, 255, 255, 0.2);
				color: #000
			}

			.highlight {
				color: #ff79c6;
				font-weight: bold
			}

			.comment {
				color: #6a9955
			}

			.status-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
				gap: 20px;
				margin: 1.5rem 0
			}

			.status-card {
				background: white;
				border-radius: 12px;
				padding: 20px;
				text-align: center;
				box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
				border-top: 4px solid var(--accent)
			}

			.status-value {
				font-size: 2.5rem;
				font-weight: bold;
				margin: 15px 0;
				color: var(--primary)
			}

			.status-label {
				font-size: 1.1rem;
				color: var(--gray)
			}

			.btn {
				display: inline-block;
				background: var(--primary);
				color: white;
				padding: 12px 25px;
				border: 0;
				border-radius: 8px;
				font-size: 1rem;
				font-weight: 500;
				cursor: pointer;
				transition: all .3s ease;
				text-align: center;
				box-shadow: 0 4px 6px rgba(67, 97, 238, 0.3)
			}

			.btn:hover {
				background: var(--secondary);
				transform: translateY(-3px);
				box-shadow: 0 6px 12px rgba(67, 97, 238, 0.4)
			}

			.btn i {
				margin-right: 8px
			}

			.demo-area {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 30px;
				margin: 2rem 0
			}

			.demo-panel {
				background: white;
				border-radius: 15px;
				padding: 25px;
				box-shadow: 0 6px 15px rgba(0, 0, 0, 0.08)
			}

			.demo-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 20px
			}

			.demo-content {
				min-height: 300px;
				border: 2px dashed rgba(67, 97, 238, 0.3);
				border-radius: 10px;
				padding: 20px;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				text-align: center;
				transition: all .3s ease
			}

			.demo-content.loaded {
				border-color: var(--success);
				background: rgba(76, 201, 240, 0.05)
			}

			.demo-content.error {
				border-color: var(--danger);
				background: rgba(247, 37, 133, 0.05)
			}

			.demo-placeholder {
				color: var(--gray);
				font-size: 1.1rem
			}

			.event-log {
				background: #f8f9fa;
				border-radius: 8px;
				padding: 15px;
				max-height: 200px;
				overflow-y: auto;
				margin-top: 15px;
				font-family: monospace;
				font-size: .9rem
			}

			.event-entry {
				padding: 8px 0;
				border-bottom: 1px solid #eee
			}

			.event-entry:last-child {
				border-bottom: 0
			}

			.event-time {
				color: var(--gray);
				margin-right: 10px
			}

			.event-success {
				color: #28a745
			}

			.event-error {
				color: #dc3545
			}

			.event-info {
				color: #17a2b8
			}

			footer {
				text-align: center;
				padding: 2rem;
				color: #666;
				font-size: 1rem;
				margin-top: 2rem;
				border-top: 1px solid rgba(0, 0, 0, 0.1)
			}

			textarea {
				width: 100%;
				height: 500px;
				padding: 10px;
				font-family: monospace;
				font-size: 14px;
				border-radius: 6px;
				box-sizing: border-box;
				background: #2d2d2d;
				color: var(--light);
				readOnly: true;
				resize: none;
				border: 0;
				outline: 0;
				white-space: pre-wrap;
				overflow-wrap: break-word
			}

			@media(max-width:992px) {
				.dashboard {
					grid-template-columns: 1fr
				}

				.demo-area {
					grid-template-columns: 1fr
				}

				.features-grid {
					grid-template-columns: 1fr
				}
			}

			@media(max-width:768px) {
				h1 {
					font-size: 2.2rem
				}

				.subtitle {
					font-size: 1.1rem
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<header>
				<h1>Fetch & Fill <i class="fas fa-crown"></i></h1>
				<p class="subtitle">Untuk memuat konten dinamis dengan caching, sanitasi, event custom, dan validasi ketat</p>
				<div class="badge-features">
					<span class="badge">Zero Null Errors</span>
					<span class="badge">Built-in Sanitization</span>
					<span class="badge">SPA Optimized</span>
					<span class="badge">Custom Events</span>
					<span class="badge">Smart Caching</span>
				</div>
			</header>
			<div class="card">
				<div class="card-header">
					<h2><i class="fas fa-star"></i> Fitur Unggulan</h2>
				</div>
				<div class="features-grid">
					<div class="feature">
						<i class="fas fa-shield-alt"></i>
						<div>
							<h3>Sanitasi Hybrid</h3>
							<p>Kombinasi DOMPurify + sanitizer fallback untuk keamanan maksimal</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-bolt"></i>
						<div>
							<h3>Caching Cerdas</h3>
							<p>Strategi cache fleksibel (memory, session, none) untuk performa optimal</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-bell"></i>
						<div>
							<h3>Event Custom</h3>
							<p>Lifecycle events untuk integrasi dengan framework modern</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-search"></i>
						<div>
							<h3>Validasi Ketat</h3>
							<p>Validasi selector dan parameter untuk mencegah runtime errors</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-sync-alt"></i>
						<div>
							<h3>Retry Otomatis</h3>
							<p>Mekanisme retry dengan exponential backoff untuk jaringan tidak stabil</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-project-diagram"></i>
						<div>
							<h3>SPA Ready</h3>
							<p>Manajemen siklus hidup komponen dengan AbortController</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-broom"></i>
						<div>
							<h3>Pembersihan Otomatis</h3>
							<p>Loader akan dibersihkan otomatis saat navigasi SPA, tab ditutup, atau halaman disembunyikan.</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-clock"></i>
						<div>
							<h3>Lazy Loading</h3>
							<p>Konten baru di-load hanya saat kontainer masuk viewport, hemat resource dan mempercepat tampilan awal.</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-object-group"></i>
						<div>
							<h3>Penempatan Fleksibel</h3>
							<p>Konten dapat di-replace, append, prepend, atau disisipkan sebelum/sesudah elemen tertentu.</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-code"></i>
						<div>
							<h3>Reinisialisasi Script Aman</h3>
							<p>Script inline di-load ulang secara aman, menjaga fungsionalitas widget dinamis.</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-exclamation-circle"></i>
						<div>
							<h3>UI Error Interaktif</h3>
							<p>Jika gagal, muncul UI error dengan tombol "Coba Lagi" untuk retry otomatis.</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-list"></i>
						<div>
							<h3>Registry Loader Global</h3>
							<p>Tracking dan manajemen semua loader aktif, bisa di-abort massal untuk efisiensi memory.</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-times-circle"></i>
						<div>
							<h3>Abort Eksternal</h3>
							<p>Dukungan AbortController untuk membatalkan fetch secara manual</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-hammer"></i>
						<div>
							<h3>Sanitizer Kustom</h3>
							<p>Atur tag/atribut yang boleh disisipkan dengan opsi sanitasi</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-magic"></i>
						<div>
							<h3>Observer Dinamis</h3>
							<p>Mendeteksi elemen yang baru muncul di DOM dengan MutationObserver</p>
						</div>
					</div>
					<div class="feature">
						<i class="fas fa-undo-alt"></i>
						<div>
							<h3>Exponential Backoff</h3>
							<p>Logika retry yang cerdas: 1s → 2s → 4s → 8s</p>
						</div>
					</div>
				</div>
			</div>
			<div class="status-grid">
				<div class="status-card">
					<i class="fas fa-dna icon-large"></i>
					<div class="status-value">Dynamic</div>
					<div class="status-label">Elemen Dinamis</div>
				</div>
				<div class="status-card">
					<i class="fas fa-bolt icon-large"></i>
					<div class="status-value">SPA Ready</div>
					<div class="status-label">Navigasi SPA</div>
				</div>
				<div class="status-card">
					<i class="fas fa-shield-virus icon-large"></i>
					<div class="status-value">DOMPurify</div>
					<div class="status-label">Sanitasi HTML</div>
				</div>
				<div class="status-card">
					<i class="fas fa-code icon-large"></i>
					<div class="status-value">2.7KB</div>
					<div class="status-label">Ukuran Minified</div>
				</div>
			</div>
			<div class="card">
				<div class="card-header">
					<h2><i class="fas fa-code"></i> Implementasi</h2>
				</div>
				<div class="tabs">
					<div class="tab active" data-tab="code">Kode Utama</div>
					<div class="tab" data-tab="tag">Script Tag</div>
					<div class="tab" data-tab="usage">Cara Penggunaan</div>
					<div class="tab" data-tab="events">Event Custom</div>
					<div class="tab" data-tab="options">Opsi Lengkap</div>
				</div>
				<div class="tab-content active" id="code-content">
					<div class="code-block">
						<div class="code-header">
							<div>FetchAndFill-Module.js</div>
							<div class="actions-btn">
								<button class="copy-btn" data-clipboard-target="#modul-code">
								<i class="fas fa-copy"></i> Salin Kode
								</button>
								<button class="download-btn" id="download-btn">
								<i class="fas fa-download"></i> Download Kode
								</button>
								<button class="open-btn" id="open-btn">
								<i class="fas fa-link"></i> Buka Kode
								</button>
							</div>
						</div>
						<textarea id="modul-code" readOnly="true">
/**
 * Fetch & Fill
 * 
 * Fitur utama:
 * - Sanitasi hybrid (DOMPurify + fallback)
 * - Caching strategis (memory, session, none)
 * - Event custom lifecycle
 * - Validasi selector ketat
 * - Retry dengan exponential backoff
 * - Manajemen siklus hidup SPA
 * - Auto cleanup
 * - Lazy Load
 */

const fetchCache = new Map();
const EVENT_PREFIX = 'fetchandfill:';
const activeLoaders = new Set(); // Global registry for active loaders

// Fungsi cleanup global
function cleanupAllLoaders() {
	activeLoaders.forEach(loader => loader.abort());
	activeLoaders.clear();
}

// Auto cleanup saat navigasi SPA (PopState/PushState)
function setupSPACleanup() {
	try {
		const originalPushState = history.pushState;
		const originalReplaceState = history.replaceState;

		history.pushState = function () {
			originalPushState.apply(this, arguments);
			window.dispatchEvent(new Event('spa-navigate'));
		};

		history.replaceState = function () {
			originalReplaceState.apply(this, arguments);
			window.dispatchEvent(new Event('spa-navigate'));
		};

		// Tangkap event popstate (back/forward)
		window.addEventListener('popstate', () => {
			window.dispatchEvent(new Event('spa-navigate'));
		});

		// Tangkap event navigasi dan cleanup
		window.addEventListener('spa-navigate', cleanupAllLoaders);

	} catch (error) {
		console.error('SPA cleanup setup failed:', error);
		// Fallback: cleanup on every load
		window.addEventListener('load', cleanupAllLoaders);
	}
}

// Auto cleanup saat window ditutup
function setupWindowCleanup() {
	window.addEventListener('beforeunload', cleanupAllLoaders);
	window.addEventListener('pagehide', cleanupAllLoaders);

	// Visibility API untuk tab background
	document.addEventListener('visibilitychange', () => {
		if (document.visibilityState === 'hidden') {
			cleanupAllLoaders();
		}
	});
}

// Inisialisasi auto cleanup (hanya di browser)
if (typeof window !== 'undefined') {
	setupSPACleanup();
	setupWindowCleanup();
}

//lazy loading
const lazyConfig = {
	enabled: true,
	margin: '200px',
	threshold: 0.01,
	disableForAboveFold: true
};

function configureLazyLoading(options = {}) {
	Object.assign(lazyConfig, options);
	console.log('Lazy loading configuration updated:', lazyConfig);
}

function isElementInViewport(el) {
	const rect = el.getBoundingClientRect();
	return (
		rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
		rect.bottom >= 0 &&
		rect.left <= (window.innerWidth || document.documentElement.clientWidth) &&
		rect.right >= 0
	);
}

//fungsi utama
function fetchAndFill(src, targetSelector, options = {}) {
	// Validasi ketat parameter input
	if (typeof src !== 'string' || !src.trim()) {
		throw new TypeError('Parameter src harus berupa string non-kosong');
	}

	if (typeof targetSelector !== 'string' || !targetSelector.trim()) {
		throw new TypeError('Parameter targetSelector harus berupa selector CSS yang valid');
	}

	// Konfigurasi default
	const config = {
		position: 'replace',
		relativeTo: null,
		runScripts: false,
		sanitize: true,
		sanitizerOptions: {
			ADD_TAGS: ['safe-custom-element'],
			FORBID_TAGS: ['script', 'iframe', 'object', 'embed'],
			FORBID_ATTR: ['onload', 'onerror', 'onclick'],
			ADD_ATTR: ['data-safe-attr']
		},
		cache: 'memory',
		maxRetries: 2,
		retryDelay: 1000,
		timeout: 30000,
		signal: null,
		...options
	};

	let lazyObserver;

	// Fungsi lazy observer
	function setupLazyObserver(target) {

		if (!('IntersectionObserver' in window)) {
			console.warn('IntersectionObserver not supported. Loading immediately.');
			proceedFill(target);
			return;
		}

		dispatchEvent('lazy-wait', {
			src,
			target
		});

		lazyObserver = new IntersectionObserver((entries) => {
			entries.forEach(entry => {
				if (entry.isIntersecting) {
					lazyObserver.unobserve(target);
					dispatchEvent('lazy-trigger', {
						src,
						target
					});
					proceedFill(target);
				}
			});
		}, {
			rootMargin: lazyConfig.margin,
			threshold: lazyConfig.threshold
		});

		lazyObserver.observe(target);
	}

	// AbortController untuk manajemen lifecycle
	const controller = new AbortController();
	const abortSignal = config.signal || controller.signal;

	// State management
	let observer, timeoutId, isFilled = false,
		retryCount = 0;

	// Event dispatching
	function dispatchEvent(eventName, detail) {
		const event = new CustomEvent(EVENT_PREFIX + eventName, {
			detail
		});
		document.dispatchEvent(event);
	}

	// Cleanup resources
	function cleanup() {
		observer?.disconnect();
		lazyObserver?.disconnect();
		clearTimeout(timeoutId);
		if (!config.signal) controller.abort();
		dispatchEvent('cleanup', {
			src,
			targetSelector
		});
	}

	// Validasi selector
	function validateSelector(selector) {
		if (!selector || typeof selector !== 'string' || selector.trim() === '') {
			return false;
		}

		try {
			// Coba buat elemen dummy untuk validasi
			const temp = document.createElement('div');
			const testEl = document.createElement('div');
			temp.appendChild(testEl);

			// Coba query selector
			temp.querySelector(selector);
			return true;
		} catch (e) {
			console.warn(`Selector validation warning: "${selector}" - ${e.message}`);
			return false;
		}
	}

	// Main processing
	async function proceedFill(target) {
		if (isFilled) return;
		isFilled = true;

		try {
			// Validasi selector utama WAJIB
			if (!validateSelector(targetSelector)) {
				throw new Error(`Target selector invalid: "${targetSelector}"`);
			}

			// Validasi relativeTo selector jika ada (FIXED: Skip if empty)
			if (config.relativeTo && !validateSelector(config.relativeTo)) {
				console.warn(`Relative selector invalid: "${config.relativeTo}" - using fallback`);
				config.relativeTo = null;
			}

			dispatchEvent('start', {
				src,
				target,
				config
			});

			let html = null;
			const cacheKey = `cache:${src}`;

			// Cek cache berdasarkan strategi
			if (config.cache !== 'none') {
				if (config.cache === 'memory' && fetchCache.has(cacheKey)) {
					html = fetchCache.get(cacheKey);
					dispatchEvent('cachehit', {
						src,
						cacheType: 'memory'
					});
				} else if (config.cache === 'session') {
					const cached = sessionStorage.getItem(cacheKey);
					if (cached) {
						html = cached;
						dispatchEvent('cachehit', {
							src,
							cacheType: 'session'
						});
					}
				}
			}

			// Fetch jika tidak ada di cache
			if (!html) {
				const startTime = performance.now();

				const response = await fetchWithRetry(
					src,
					abortSignal,
					config.maxRetries,
					config.retryDelay
				);

				if (!response.ok) throw new Error(`HTTP ${response.status}`);

				html = await response.text();
				const duration = performance.now() - startTime;

				// Simpan ke cache
				if (config.cache === 'memory') {
					fetchCache.set(cacheKey, html);
				} else if (config.cache === 'session') {
					try {
						sessionStorage.setItem(cacheKey, html);
					} catch (e) {
						console.warn('Session storage full, cache not saved');
					}
				}

				dispatchEvent('fetch', {
					src,
					duration,
					size: html.length
				});
			}

			// Sanitasi HTML
			let sanitizedHtml = html;
			if (config.sanitize) {
				if (typeof DOMPurify !== 'undefined') {
					sanitizedHtml = DOMPurify.sanitize(html, config.sanitizerOptions);
				} else {
					sanitizedHtml = fallbackSanitize(html);
					dispatchEvent('fallbacksanitize', {
						src
					});
				}
			}

			// Parse dan siapkan konten
			const doc = new DOMParser().parseFromString(sanitizedHtml, 'text/html');
			const fragment = document.createDocumentFragment();

			while (doc.body.firstChild) {
				fragment.appendChild(doc.body.firstChild);
			}

			// Penempatan konten
			handlePosition(target, fragment, config.position, config.relativeTo);

			// Jalankan script jika diizinkan
			if (config.runScripts) {
				reinitScripts(target, config.sanitize);
			}

			dispatchEvent('success', {
				src,
				target,
				fragment
			});

		} catch (err) {
			if (err.name !== 'AbortError') {
				console.error(`[fetchAndFill] Error loading "${src}"`, err);
				dispatchEvent('error', {
					src,
					target,
					error: err
				});

				// Fallback UI untuk error (FIXED: null element handling)
				if (target && config.position === 'replace') {
					displayError(target, err, src);
				} else {
					console.error('Cannot display error UI - target element not available');
				}
			}
		}
	}

	// Implementasi fetch dengan retry
	async function fetchWithRetry(url, signal, maxRetries, retryDelay) {
		try {
			const response = await fetch(url, {
				signal
			});

			if (response.ok) return response;

			if (response.status >= 500 && retryCount < maxRetries) {
				throw new Error(`HTTP ${response.status}`);
			}

			return response;
		} catch (err) {
			if (retryCount < maxRetries) {
				retryCount++;
				const delay = retryDelay * Math.pow(2, retryCount);

				dispatchEvent('retry', {
					src,
					retryCount,
					delay
				});

				await new Promise(res => setTimeout(res, delay));
				return fetchWithRetry(url, signal, maxRetries, retryDelay);
			}
			throw err;
		}
	}

	// Fallback sanitizer jika DOMPurify tidak tersedia
	function fallbackSanitize(html) {
		const temp = document.createElement('div');
		temp.innerHTML = html;

		// Hapus elemen berbahaya
		const forbidden = ['script', 'iframe', 'object', 'embed', 'form', 'link'];
		forbidden.forEach(tag => {
			temp.querySelectorAll(tag).forEach(el => el.remove());
		});

		// Hapus atribut berbahaya
		temp.querySelectorAll('*').forEach(el => {
			const attrs = el.attributes;
			for (let i = attrs.length - 1; i >= 0; i--) {
				const attr = attrs[i];
				if (attr.name.startsWith('on') ||
					(attr.name === 'src' && /^javascript:/i.test(attr.value)) ||
					(attr.name === 'href' && /^javascript:/i.test(attr.value)) ||
					(attr.name === 'style' && /expression|javascript/i.test(attr.value))) {
					el.removeAttribute(attr.name);
				}
			}
		});

		return temp.innerHTML;
	}

	// Error handling UI
	function displayError(target, error, src) {
		// Pastikan target valid
		if (!target || !(target instanceof Element)) {
			console.error('Cannot display error - invalid target element');
			return;
		}

		const errorEl = document.createElement('div');
		errorEl.className = 'fetch-fill-error';
		errorEl.innerHTML = `
										<div style="text-align:center; padding:30px;">
											<i class="fas fa-exclamation-triangle" style="font-size:3rem;color:#f72585;"></i>
											<h3 style="margin:15px 0;color:#dc3545;">Gagal Memuat Konten</h3>
											<p>${error.message}</p>
											<p style="font-size:0.9rem;margin-top:10px;color:#6c757d;">Source: ${src}</p>
											<button class="btn" style="margin-top:20px;background:var(--danger);">
												<i class="fas fa-redo"></i> Coba Lagi
											</button>
										</div>
									`;

		// Null check sebelum menambahkan event listener
		const btn = errorEl.querySelector('.btn');
		if (btn) {
			btn.addEventListener('click', () => {
				errorEl.remove();
				isFilled = false;
				retryCount = 0;
				proceedFill(target);
			});
		} else {
			console.error('Error button element not found in error UI');
		}

		target.replaceChildren(errorEl);
	}

	// Position handling logic
	function handlePosition(target, fragment, position, relativeTo) {
		switch (position) {
			case 'replace':
				target.replaceChildren(fragment);
				break;
			case 'append':
				target.appendChild(fragment);
				break;
			case 'prepend':
				target.prepend(fragment);
				break;
			case 'before':
			case 'after':
				if (!relativeTo) throw new Error('relativeTo required for before/after');
				const ref = target.querySelector(relativeTo);
				if (ref) {
					ref[position](fragment);
				} else {
					console.warn(`Reference not found: ${relativeTo} - using append`);
					target.appendChild(fragment);
				}
				break;
			default:
				throw new Error(`Invalid position: ${position}`);
		}
	}

	// Reinitialize scripts dengan penanganan khusus
	function reinitScripts(container, isSanitized) {
		container.querySelectorAll('script').forEach(oldScript => {
			// Skip external scripts jika disanitasi
			if (isSanitized && oldScript.src) {
				console.warn('Skipping external script for security');
				return;
			}

			const newScript = document.createElement('script');

			// Copy attributes
			Array.from(oldScript.attributes).forEach(attr => {
				// Skip event attributes jika disanitasi
				if (!isSanitized || !attr.name.startsWith('on')) {
					newScript.setAttribute(attr.name, attr.value);
				}
			});

			// Copy content (hanya untuk inline scripts)
			if (!oldScript.src) {
				newScript.textContent = oldScript.textContent;
			}

			// Replace dengan penanganan error
			try {
				oldScript.replaceWith(newScript);
			} catch (err) {
				console.error('Script replacement error', err);
			}
		});
	}

	// Observer callback
	function mutationCallback() {
		const target = document.querySelector(targetSelector);
		if (target && !isFilled) {
			cleanup();
			if (lazyConfig.enabled && (!lazyConfig.disableForAboveFold || !isElementInViewport(target))) {
				setupLazyObserver(target);
			} else {
				proceedFill(target);
			}
		}
	}

	// Eksekusi awal
	try {
		validateSelector(targetSelector);

		const target = document.querySelector(targetSelector);
		if (target) {
			// Gunakan lazy loading jika diaktifkan dan elemen tidak terlihat
			if (lazyConfig.enabled && (!lazyConfig.disableForAboveFold || !isElementInViewport(target))) {
				setupLazyObserver(target);
			} else {
				proceedFill(target);
			}
		} else {
			// Setup observer untuk target yang belum ada
			observer = new MutationObserver(mutationCallback);
			observer.observe(document.documentElement, {
				childList: true,
				subtree: true,
				attributeFilter: ['id', 'class']
			});

			// Timeout fallback
			timeoutId = setTimeout(() => {
				if (!isFilled) {
					enhancedCleanup();
					const err = new Error(`Target element not found: ${targetSelector}`);
					dispatchEvent('error', {
						src,
						error: err
					});
					throw err;
				}
			}, config.timeout);

			// Handle abort signal
			abortSignal.addEventListener('abort', enhancedCleanup);
		}
	} catch (err) {
		dispatchEvent('error', {
			src,
			error: err
		});
		throw err;
	}

	// Buat objek loader
	const loader = {
		abort: cleanup,
		on: (event, handler) => {
			const eventName = EVENT_PREFIX + event;
			document.addEventListener(eventName, handler);
			return () => document.removeEventListener(eventName, handler);
		}
	};

	// Daftarkan loader ke registry global
	activeLoaders.add(loader);

	// fungsi cleanup baru yang akan membersihkan dan unregister
	const enhancedCleanup = () => {
		cleanup(); // panggil cleanup asli
		activeLoaders.delete(loader); // unregister
	};

	// Ganti metode abort pada loader
	loader.abort = enhancedCleanup;

	// Kembalikan loader
	return loader;
}

// Ekspos fungsi 
export {
	fetchAndFill,
	cleanupAllLoaders,
	configureLazyLoading
};
						</textarea>
					</div>
				</div>
				
				<div class="tab-content " id="tag-content">
					<div class="code-block">
						<div class="code-header">
							<div>Script Tag</div>
							<div class="actions-btn">
								<button class="copy-btn" data-clipboard-target="#script-tag">
								<i class="fas fa-copy"></i> Salin
								</button>
							</div>
						</div>
						<textarea style="height: 35px;" id="script-tag" readOnly="true">
<script src="https://mbahbabat.github.io/spa/FetchAndFill-Module.js " type="module"></script>
					</textarea>
					</div>
				</div>
				
				<div class="tab-content" id="usage-content">
					<div class="code-block">
						<div class="code-header">
							<div>Contoh Penggunaan</div>
							<button class="copy-btn" data-clipboard-target="#usage-code">
							<i class="fas fa-copy"></i> Salin
							</button>
						</div>
						<textarea id="usage-code" readOnly="true">
// 1. Penggunaan dasar
const loader = fetchAndFill('partials/header.html', '#header');

// 2. Dengan opsi lanjutan
const contentLoader = fetchAndFill('user-content.html', '#main', {
	position: 'after',
	relativeTo: '.insert-after-me',
	sanitize: true,
	cache: 'session',
	maxRetries: 3
});

// 3. Dengan event handling
const eventLoader = fetchAndFill('dashboard.html', '#dashboard');
eventLoader.on('success', (e) => {
	console.log('Konten dimuat:', e.detail);
});
eventLoader.on('error', (e) => {
	console.error('Error:', e.detail.error);
});

// 4. Menggunakan AbortController untuk SPA
let contentController;

function loadPage(url) {
	// Hentikan pemuatan sebelumnya
	if (contentController) contentController.abort();

	// Muat konten baru
	const controller = new AbortController();
	contentController = controller;

	fetchAndFill(url, '#app', {
		signal: controller.signal,
		cache: 'memory'
	});
}

// 5. Cleanup saat komponen di-unmount
function setupComponent() {
	const loader = fetchAndFill('widget.html', '#widget');
	return loader.abort;
}

// Saat komponen di-unmount
const cleanup = setupComponent();
cleanup();
						</textarea>
					</div>
				</div>

				<div class="tab-content" id="events-content">
					<div class="code-block">
						<div class="code-header">
							<div>Event Custom</div>
							<button class="copy-btn" data-clipboard-target="#events-code">
							<i class="fas fa-copy"></i> Salin
							</button>
						</div>
						<textarea id="events-code" readOnly="true">
/**
 * Daftar Event Custom:
 * 
 * fetchandfill:start
 *   - Terpanggil saat proses dimulai
 *   - Detail: { src, target, config }
 * 
 * fetchandfill:fetch
 *   - Terpanggil setelah fetch berhasil
 *   - Detail: { src, duration, size }
 * 
 * fetchandfill:cachehit
 *   - Terpanggil saat menggunakan cache
 *   - Detail: { src, cacheType }
 * 
 * fetchandfill:retry
 *   - Terpanggil saat retry dilakukan
 *   - Detail: { src, retryCount, delay }
 * 
 * fetchandfill:fallbacksanitize
 *   - Terpanggil saat menggunakan sanitizer fallback
 *   - Detail: { src }
 * 
 * fetchandfill:success
 *   - Terpanggil saat konten berhasil dimuat
 *   - Detail: { src, target, fragment }
 * 
 * fetchandfill:error
 *   - Terpanggil saat terjadi error
 *   - Detail: { src, target, error }
 * 
 * fetchandfill:cleanup
 *   - Terpanggil saat resources dibersihkan
 *   - Detail: { src, targetSelector }
 */

// Contoh penggunaan event:
document.addEventListener('fetchandfill:success', (e) => {
	console.log('Konten dimuat:', e.detail.src);
	// Lakukan inisialisasi tambahan
});

document.addEventListener('fetchandfill:error', (e) => {
	console.error('Error:', e.detail.error.message);
	// Tampilkan notifikasi error
});
						</textarea>
					</div>
				</div>
				<div class="tab-content" id="options-content">
					<div class="code-block">
						<div class="code-header">
							<div>Opsi Lengkap</div>
							<button class="copy-btn" data-clipboard-target="#options-code">
							<i class="fas fa-copy"></i> Salin
							</button>
						</div>
						<textarea id="options-code" readOnly="true">
/**
 * Opsi Konfigurasi:
 * 
 * position: 'replace' | 'append' | 'prepend' | 'before' | 'after'
 *   - Posisi penempatan konten (default: 'replace')
 * 
 * relativeTo: string (selector)
 *   - Wajib untuk opsi 'before' dan 'after'
 *   - Selector elemen referensi
 * 
 * runScripts: boolean
 *   - Apakah menjalankan script yang ada di konten
 *   - Default: false (keamanan)
 * 
 * sanitize: boolean
 *   - Apakah melakukan sanitasi konten
 *   - Default: true (keamanan)
 * 
 * sanitizerOptions: object
 *   - Opsi untuk DOMPurify
 *   - Default: { ... }
 * 
 * cache: 'memory' | 'session' | 'none'
 *   - Strategi caching:
 *     - 'memory': cache di memory (hanya untuk sesi halaman)
 *     - 'session': cache di sessionStorage (bertahan sampai tab ditutup)
 *     - 'none': tidak menggunakan cache
 *   - Default: 'memory'
 * 
 * maxRetries: number
 *   - Jumlah maksimal percobaan ulang
 *   - Default: 2
 * 
 * retryDelay: number
 *   - Delay awal untuk retry (ms)
 *   - Delay akan berlipat ganda setiap retry (exponential backoff)
 *   - Default: 1000
 * 
 * timeout: number
 *   - Waktu tunggu maksimal untuk menemukan target (ms)
 *   - Default: 30000 (30 detik)
 * 
 * signal: AbortSignal
 *   - Sinyal untuk membatalkan proses
 *   - Berguna untuk manajemen lifecycle di SPA
 */
						</textarea>
					</div>
				</div>
			</div>
			<div class="demo-area">
				<div class="demo-panel">
					<div class="demo-header">
						<h3><i class="fas fa-flask"></i> Demo Area</h3>
						<button id="loadDemo" class="btn">
						<i class="fas fa-download"></i> Muat Konten
						</button>
					</div>
					<div id="demoContent" class="demo-content">
						<div class="demo-placeholder">
							<i class="fas fa-cloud-download-alt" style="font-size:4rem;color:#4361ee;margin-bottom:20px;"></i>
							<p>Klik "Muat Konten" untuk melihat aksi</p>
						</div>
					</div>
					<div class="event-log" id="eventLog"></div>
				</div>
				<div class="demo-panel">
					<div class="demo-header">
						<h3><i class="fas fa-bug"></i> Error Handling</h3>
						<button id="loadError" class="btn" style="background:var(--danger);">
						<i class="fas fa-exclamation-triangle"></i> Muat Error
						</button>
					</div>
					<div id="errorContent" class="demo-content">
						<div class="demo-placeholder">
							<i class="fas fa-bug" style="font-size:4rem;color:#f72585;margin-bottom:20px;"></i>
							<p>Klik "Muat Error" untuk uji penanganan error</p>
						</div>
					</div>
					<div class="event-log" id="errorLog"></div>
				</div>
			</div>
			<div class="card">
				<div class="card-header">
					<h2><i class="fas fa-graduation-cap"></i> Dokumentasi Lengkap</h2>
					<button class="copy-btn" data-clipboard-target="#module-documentation">
					<i class="fas fa-copy"></i> Salin
					</button>
				</div>
				<div class="code-block">
					<textarea style="height:1000px" id="module-documentation" readOnly="true">
================================================================================
DOKUMENTASI MODUL Fetch & Fill
================================================================================

Penulis: Mbah Babat
Script: FetchAndFill-Module.js
Tujuan: Melakukan pengambilan (fetch) HTML dinamis, pengisian kontainer, dan manajemen siklus hidup untuk aplikasi web modern, dengan fitur-fitur canggih untuk SPA, keamanan, cache, dan lazy loading.

================================================================================
DAFTAR ISI
================================================================================
1. Ringkasan & Fitur
2. Variabel Global & Konfigurasi
3. Manajemen Siklus Hidup
   - Cleanup Global
   - Auto Cleanup Navigasi SPA
   - Cleanup Window/Tab
4. Lazy Loading
   - Konfigurasi
   - Deteksi
   - Setup
5. Fungsi Utama: fetchAndFill
   - Parameter & Validasi
   - Opsi Konfigurasi
   - Siklus Fetch
   - Caching
   - Sanitasi
   - Manipulasi DOM
   - Inisialisasi Ulang Script
   - Penanganan Error & UI
   - Penempatan Konten
   - Observer & Mutasi
   - Objek Loader & Event
6. Utilitas & Helper
   - Validasi
   - Sanitasi Cadangan
   - Dispatch Event
   - UI Error
   - Cleanup Lanjutan
7. API Export
8. Contoh Penggunaan
9. Referensi Event
10. Catatan Keamanan
11. Keterbatasan & Isu
12. Changelog & Kredit

================================================================================
1. RINGKASAN & FITUR
================================================================================

Modul FetchAndFill memungkinkan pemuatan konten dinamis yang aman dan fleksibel ke dalam kontainer HTML. Dirancang untuk SPA dan website modern, dengan fitur:

- **Sanitasi Hybrid HTML**: Menggunakan DOMPurify jika tersedia, fallback ke sanitizer custom.
- **Cache Strategis**: Mendukung cache memory, sessionStorage, atau tanpa cache.
- **Event Lifecycle Custom**: Semua aksi utama berbasis event dan dapat di-observasi.
- **Validasi Selector Ketat**: Memastikan selector target valid.
- **Logika Retry**: Backoff eksponensial untuk fetch gagal.
- **Manajemen Siklus Hidup SPA**: Cleanup otomatis saat navigasi.
- **Auto Cleanup**: Membersihkan pada tab hide, unload, navigasi, dll.
- **Lazy Load Support**: Konten di-load saat kontainer masuk viewport.
- **Penempatan Fleksibel**: Replace, append, prepend, before, after.
- **Reinisialisasi Script**: Script inline diinject ulang dengan aman.
- **UI Penanganan Error**: Menampilkan pesan error ramah pengguna dengan tombol retry.
- **Global Loader Registry**: Tracking dan abort semua loader aktif.
- **Event Hooks**: Bisa listen dan merespon semua event lifecycle.

================================================================================
2. VARIABEL GLOBAL & KONFIGURASI
================================================================================

- `fetchCache`: Map untuk cache memory.
- `EVENT_PREFIX`: Prefix semua event custom (`fetchandfill:`).
- `activeLoaders`: Set loader aktif saat ini.
- `lazyConfig`: Konfigurasi lazy loading:
    - enabled: true/false
    - margin: rootMargin untuk IntersectionObserver
    - threshold: Ambang Intersection
    - disableForAboveFold: Jika true, lazy load dinonaktifkan untuk kontainer yang terlihat

================================================================================
3. MANAJEMEN SIKLUS HIDUP
================================================================================

3.1. **Cleanup Global**  
- `cleanupAllLoaders()`: Abort semua loader aktif, clear registry global.

3.2. **Auto Cleanup Navigasi SPA**  
- `setupSPACleanup()`: Monkey-patch `history.pushState` dan `replaceState` untuk dispatch event custom (`spa-navigate`) saat navigasi. Juga listen `popstate` dan trigger cleanup.

3.3. **Cleanup Window/Tab**  
- `setupWindowCleanup()`: Listen `beforeunload`, `pagehide`, dan `visibilitychange` (hidden) untuk trigger cleanup.

Semua logika cleanup diinisialisasi otomatis jika `window` tersedia.

================================================================================
4. LAZY LOADING
================================================================================

- `configureLazyLoading(options)`: Update lazyConfig secara global.
- `isElementInViewport(el)`: Cek apakah elemen terlihat di viewport.
- Lazy loading dipicu jika enable dan elemen tidak di atas layar (atau disableForAboveFold = false).

IntersectionObserver dipakai jika tersedia; jika tidak, load langsung.

================================================================================
5. FUNGSI UTAMA: fetchAndFill
================================================================================

`fetchAndFill(src, targetSelector, options = {})`

Parameter:
- `src`: String. URL untuk fetch HTML. (Wajib)
- `targetSelector`: String. Selector CSS kontainer. (Wajib)
- `options`: Object. Konfigurasi opsional.

Validasi:
- Throw TypeError jika `src` atau `targetSelector` tidak valid.

Konfigurasi Default (`config`):
- `position`: Cara insert HTML (`replace`, `append`, `prepend`, `before`, `after`)
- `relativeTo`: Selector referensi (untuk `before`/`after`)
- `runScripts`: Apakah script diinisialisasi ulang
- `sanitize`: Gunakan sanitasi (DOMPurify atau fallback)
- `sanitizerOptions`: Opsi untuk DOMPurify
- `cache`: `'memory'`, `'session'`, atau `'none'`
- `maxRetries`: Jumlah retry fetch
- `retryDelay`: Delay awal (ms) untuk retry
- `timeout`: Waktu maksimal tunggu target (ms)
- `signal`: Optional AbortSignal

Objek Loader:
- `abort()`: Abort loader dan unregister dari registry global.
- `on(event, handler)`: Subscribe ke event custom; return fungsi unsubscribe.

================================================================================
Siklus Fetch
================================================================================

1. **Penanganan AbortController**
   - Fungsi fetchWithRetry menggunakan AbortController untuk membatalkan proses fetch jika:
     - Ada sinyal abort eksternal (`options.signal`).
     - Loader di-abort melalui fungsi `cleanup()`.
   - Jika fetch di-abort, error dengan nama `AbortError` tidak akan memicu event error.

2. **Detail Exponential Backoff**
   - Formula retry: `delay = retryDelay * 2^(retryCount)`.
   - Contoh: retryDelay=1000, maxRetries=3 -> Delay: 1000ms, 2000ms, 4000ms.
   - Retry hanya dilakukan untuk error:
     - Network failure (gagal jaringan).
     - HTTP status 5xx (server error).
3. **Validasi Selector**: Pastikan selector valid secara sintaks.
4. **Deteksi Target**: Cari elemen target.
   - Jika ketemu: lanjut (lazy atau langsung fill).
   - Jika tidak: Setup MutationObserver untuk elemen dinamis.
5. **Lazy Loading**: Jika enable, tunggu elemen masuk viewport.
6. **Fetch & Caching**: Load dari cache jika ada, jika tidak fetch baru.
   - Cache memory: `fetchCache`
   - Cache session: `sessionStorage`
7. **Retry Logic**: Error network/HTTP 5xx, lakukan backoff eksponensial.
8. **Sanitasi**: HTML disanitasi via DOMPurify atau fallback.
9. **Manipulasi DOM**: DocumentFragment dibuat dan diinsert sesuai posisi.
10. **Reinisialisasi Script**: Script inline diinject ulang jika diizinkan.
11. **Penanganan Error**: Tampilkan UI error di kontainer dengan tombol retry.
12. **Cleanup**: Observer, timer, signal dibersihkan saat abort/sukses.

================================================================================
Observer & Mutasi
================================================================================

- **Mutation Observer**
  - Digunakan untuk mendeteksi kemunculan targetSelector jika belum ada di DOM.
  - Observer disetting dengan:
    ```javascript
    observer.observe(document.documentElement, {
      childList: true,
      subtree: true,
      attributeFilter: ['id', 'class'] // Hanya pantau perubahan id/class
    });
    ```
  - Observer akan di-disconnect saat target ditemukan atau terjadi timeout.

================================================================================
6. UTILITAS & HELPER
================================================================================

- `validateSelector(selector)`: True jika selector valid.
- `dispatchEvent(eventName, detail)`: Dispatch custom event (`fetchandfill:<eventName>`) dengan detail.
- `cleanup()`: Disconnect observer, clear timer, abort fetch, dispatch event cleanup.
- `enhancedCleanup()`: Cleanup tambahan, unregister loader dari registry global.
- `fallbackSanitize(html)`: Hapus tag dan atribut berbahaya jika DOMPurify tidak tersedia.
- `displayError(target, error, src)`: Render error message dan tombol retry ke kontainer target.
- `handlePosition(target, fragment, position, relativeTo)`: Menempatkan fragment ke kontainer sesuai posisi.
- `reinitScripts(container, isSanitized)`: Inject ulang script, skip eksternal jika disanitasi.

================================================================================
Fallback Sanitizer
================================================================================

- **Detail Fallback Sanitizer**
  - Tag yang dihapus:
    - ['script', 'iframe', 'object', 'embed', 'form', 'link']
  - Atribut yang dihapus:
    - Semua atribut `on*` (event handlers seperti onclick, onload, dll).
    - Nilai `src`/`href` yang mengandung `javascript:`.
    - Nilai `style` yang mengandung `expression` atau `javascript`.
	
================================================================================
UI Error
================================================================================

- **UI Error Tombol Retry**
  - Klik tombol "Coba Lagi" akan:
    - Menghapus UI error dari target.
    - Mereset state loader (`isFilled=false`, `retryCount=0`).
    - Menjalankan ulang proses proceedFill().

- **Ketergantungan FontAwesome**
  - UI error menggunakan ikon `fa-exclamation-triangle` dan `fa-redo`.
  - Jika tidak menggunakan FontAwesome, ganti HTML error dengan SVG/icon teks biasa.

================================================================================
Contoh Override Custom Error UI:
================================================================================

const originalFetchAndFill = fetchAndFill;
fetchAndFill = (src, targetSelector, options) => {
  const loader = originalFetchAndFill(src, targetSelector, options);
  loader.on('error', (e) => {
    const target = document.querySelector(targetSelector);
    if (target) {
      target.innerHTML = `<div class="my-error">Custom error: ${e.detail.error.message}</div>`;
    }
  });
  return loader;
};

================================================================================
7. API EXPORT
================================================================================

Ekspor:
- `fetchAndFill`
- `cleanupAllLoaders`
- `configureLazyLoading`

================================================================================
8. CONTOH PENGGUNAAN
================================================================================

Impor modul:
    import { fetchAndFill, cleanupAllLoaders, configureLazyLoading } from './FetchAndFill-Module.js';

-------------------------------------------------------------------------------
A. fetchAndFill - Penggunaan Dasar
-------------------------------------------------------------------------------
Load konten ke dalam kontainer dengan selector:
    fetchAndFill('/widget.html', '#widget-container');
	
	

-------------------------------------------------------------------------------
B. fetchAndFill - Dengan Semua Opsi
-------------------------------------------------------------------------------
Penggunaan lanjutan dengan opsi custom:
    const loader = fetchAndFill('/content.html', '#main', {
        position: 'replace',           // 'append', 'prepend', 'before', 'after'
        relativeTo: '.reference',      // Untuk 'before'/'after'
        runScripts: true,              // Inisialisasi ulang script setelah load
        sanitize: true,                // Aktifkan sanitasi HTML
        sanitizerOptions: {
            ADD_TAGS: ['safe-custom-element'],
            FORBID_TAGS: ['script', 'iframe', 'object', 'embed'],
            FORBID_ATTR: ['onload', 'onerror', 'onclick'],
            ADD_ATTR: ['data-safe-attr']
        },
        cache: 'memory',               // 'memory', 'session', atau 'none'
        maxRetries: 3,                 // Jumlah retry fetch
        retryDelay: 1500,              // Delay retry awal (ms)
        timeout: 20000,                // Timeout tunggu elemen target (ms)
        signal: new AbortController().signal // Optional; abort eksternal
    });

-------------------------------------------------------------------------------
C. Penanganan Event - Listen Custom Event
-------------------------------------------------------------------------------
Subscribe ke event lifecycle:
    loader.on('success', e => {
        console.log('Konten berhasil diload!', e.detail);
    });

    loader.on('error', e => {
        console.error('Error fetch:', e.detail.error);
    });

    loader.on('retry', e => {
        console.log(`Retry ke-${e.detail.retryCount} setelah ${e.detail.delay}ms`);
    });

    // Unsubscribe:
    const unsubscribe = loader.on('fetch', handler);
    // ...nanti
    unsubscribe();

-------------------------------------------------------------------------------
D. Abort/Cancel Loader
-------------------------------------------------------------------------------
Abort satu loader:
    loader.abort();

Abort semua loader secara global:
    cleanupAllLoaders();
	
- **AbortController Eksternal**

  const controller = new AbortController();
  fetchAndFill('/data', '#target', {
    signal: controller.signal,
    cache: 'none'
  });

  // Batalkan setelah 3 detik
  setTimeout(() => controller.abort(), 3000);	

-------------------------------------------------------------------------------
E. Konfigurasi Lazy Loading
-------------------------------------------------------------------------------
Update pengaturan lazy loading secara global:
    configureLazyLoading({
        enabled: true,
        margin: '100px',
        threshold: 0.1,
        disableForAboveFold: false
    });

- **Optimasi Lazy/preload**
  Untuk elemen penting, nonaktifkan lazy loading:

  configureLazyLoading({ enabled: false });

-------------------------------------------------------------------------------
F. Penanganan Navigasi SPA
-------------------------------------------------------------------------------
Modul otomatis abort loader dan cleanup saat navigasi via
history.pushState, history.replaceState, atau tombol back/forward browser.
Tidak perlu kode manual.

-------------------------------------------------------------------------------
G. Cache Session Storage
-------------------------------------------------------------------------------
Gunakan cache session untuk persist fetch antar reload halaman:
    fetchAndFill('/session.html', '#container', {
        cache: 'session'
    });

- **Cache Aggresif**
  Untuk konten yang jarang berubah, gunakan:
  
  cache: 'session'
  
## Catatan Cache Session:
Hindari konten > 5MB. Gunakan:
try {
  sessionStorage.setItem(key, html)
} catch(e) {
  console.error("Cache penuh", e)
}  
	

-------------------------------------------------------------------------------
H. Penanganan Error dan UI Retry
-------------------------------------------------------------------------------
Jika fetch gagal, modul otomatis inject UI error dengan tombol retry
ke kontainer target:
    // Tidak perlu kode tambahan. Klik tombol retry akan reload lagi.

-------------------------------------------------------------------------------
I. Eksekusi Script Setelah Fetch
-------------------------------------------------------------------------------
Jalankan script inline setelah insert (hati-hati!):
    fetchAndFill('/scripts.html', '#container', {
        runScripts: true,
        sanitize: false // Hanya jika sumber konten benar-benar aman!
    });

-------------------------------------------------------------------------------
J. Opsi Sanitizer Custom
-------------------------------------------------------------------------------
Override pengaturan sanitizer untuk kebutuhan khusus:
    fetchAndFill('/custom.html', '#container', {
        sanitize: true,
        sanitizerOptions: {
            ADD_TAGS: ['custom-tag'],
            FORBID_ATTR: ['onmouseover']
        }
    });

-------------------------------------------------------------------------------
K. Multiple Loader dan Cleanup
-------------------------------------------------------------------------------
Mulai beberapa fetch sekaligus dan abort semua:
    const loader1 = fetchAndFill('/a.html', '#a');
    const loader2 = fetchAndFill('/b.html', '#b');
    // Abort semua sekaligus:
    cleanupAllLoaders();

-------------------------------------------------------------------------------
L. Manual Trigger Navigasi SPA
-------------------------------------------------------------------------------
Trigger manual navigasi SPA untuk cleanup otomatis:
    window.dispatchEvent(new Event('spa-navigate'));

-------------------------------------------------------------------------------
M. Strategi Cache Lengkap
-------------------------------------------------------------------------------
Pilihan cache dan masa hidupnya:
    cache: 'memory'   // Hanya di RAM, hilang saat reload
    cache: 'session'  // Di sessionStorage, hilang saat tab ditutup
    cache: 'none'     // Tidak ada cache

-------------------------------------------------------------------------------
N. Event Fallback Sanitizer
-------------------------------------------------------------------------------
Event jika DOMPurify tidak tersedia:
    document.addEventListener('fetchandfill:fallbacksanitize', e => {
        console.warn('Fallback sanitizer digunakan untuk:', e.detail.src);
    });

-------------------------------------------------------------------------------
O. Penggunaan cleanupAllLoaders() Lanjutan
-------------------------------------------------------------------------------
Gunakan untuk reset state atau navigasi SPA:
    cleanupAllLoaders();
    fetchAndFill('/new-content.html', '#content');

-------------------------------------------------------------------------------
P. Logika Retry dan Timeout
-------------------------------------------------------------------------------
Modul menggunakan exponential backoff:
    retryDelay * Math.pow(2, retryCount)

Contoh:
    retryDelay = 1000, maxRetries = 3 → Delay: 1s, 2s, 4s

Event retry:
    loader.on('retry', e => {
        console.log(`Retry ${e.detail.retryCount}, delay: ${e.detail.delay}ms`);
    });

-------------------------------------------------------------------------------
Q. Validasi Selector Ketat
-------------------------------------------------------------------------------
Jika selector CSS tidak valid, error akan dilempar:
    try {
        fetchAndFill('/bad.html', '#invalid[selector]');
    } catch (err) {
        console.error('Selector tidak valid:', err.message);
    }

-------------------------------------------------------------------------------
R. Event Lifecycle Lengkap
-------------------------------------------------------------------------------
Daftar custom event lifecycle:
    fetchandfill:start
    fetchandfill:cachehit
    fetchandfill:fetch
    fetchandfill:success
    fetchandfill:error
    fetchandfill:retry
    fetchandfill:lazy-wait
    fetchandfill:lazy-trigger
    fetchandfill:cleanup
    fetchandfill:fallbacksanitize

Contoh:
    document.addEventListener('fetchandfill:error', e => {
        console.error('Error global:', e.detail.error.message);
    });

-------------------------------------------------------------------------------
S. Lazy Load - Disable Above Fold Detection
-------------------------------------------------------------------------------
Secara default, modul tidak menunda loading elemen yang berada di "above the fold"
(terlihat saat halaman pertama kali dimuat). Ini untuk menjaga performa percepatan
tampilan awal halaman.

Namun, jika ingin memaksa semua elemen (termasuk yang terlihat langsung)
tetap diload secara lazy (misalnya untuk delay render atau optimasi resource),
aktifkan opsi ini:

    configureLazyLoading({
        disableForAboveFold: false  // Default: true
    });

Contoh kasus penggunaan:
- Delay render widget besar yang tidak kritis meskipun berada di atas halaman
- Optimasi LCP dengan mengatur urutan render konten
- Testing behavior lazy load tanpa harus scroll

Catatan:
- Pastikan ini sesuai dengan kebutuhan UX dan performa aplikasi .
- Untuk elemen kritis seperti header atau navigasi utama, biasanya lebih baik
  biarkan `disableForAboveFold: true` agar langsung muncul.

-------------------------------------------------------------------------------
T. Inisialisasi Ulang Script Aman
-------------------------------------------------------------------------------
Fitur `runScripts: true` akan me-reset script inline:
    fetchAndFill('/widget.html', '#widget', {
        runScripts: true,
        sanitize: false // Hanya jika benar-benar aman
    });
	
================================================================================
9. REFERENSI EVENT
================================================================================

Semua event di-dispatch sebagai `CustomEvent` ke `document` dengan prefix `fetchandfill:`.

- `start`: Saat loading dimulai
- `cachehit`: Konten diambil dari cache
- `fetch`: Fetch berhasil
- `success`: Konten berhasil diinsert
- `error`: Terjadi error (detail: error object)
- `retry`: Akan retry fetch (detail: retryCount, delay)
- `lazy-wait`: Menunggu lazy load
- `lazy-trigger`: Lazy load dipicu
- `fallbacksanitize`: Fallback sanitizer dipakai
- `cleanup`: Loader dibersihkan

Subscribe dengan:
    loader.on('event', handler);

================================================================================
10. CATATAN KEAMANAN
================================================================================

- Sangat disarankan untuk aktifkan sanitasi (`sanitize: true`). DOMPurify paling aman.
- Fallback sanitizer akan menghapus tag script/iframe/object/embed/form/link dan atribut berbahaya.
- Script eksternal otomatis di-skip jika sanitasi aktif.
- Hati-hati dengan `runScripts: true` jika sumber konten tidak terpercaya.

================================================================================
11. KETERBATASAN & ISU
================================================================================

- Jika DOMPurify tidak tersedia, sanitizer fallback mungkin tidak menutupi semua vektor XSS.
- Disarankan hanya satu loader per target.
- UI error membutuhkan FontAwesome untuk ikon (opsional, fallback ke teks).
- MutationObserver bisa berpengaruh pada performa jika berlebihan.
- Beberapa fitur (misal SPA cleanup) tergantung dukungan history API di browser.
- Konten HTML besar bisa memenuhi quota sessionStorage (cache: 'session').

- **Race Condition**
  Jika beberapa loader menargetkan elemen yang sama, bisa terjadi konflik.
  Solusi: Gunakan loader terpisah untuk target berbeda.
  
	## Best Practice:
	- Gunakan 1 loader per target selector
	- Hindari parallel load ke same target
	- Gunakan `AbortController` untuk kontrol manual

- **Memory Leak**
  Registry `activeLoaders` menyimpan reference ke loader. Pencegahan:
  Auto-cleanup memastikan tidak ada memory leak.

- **Ketergantungan FontAwesome**
  UI error menggunakan ikon dari FontAwesome. Jika tidak ada, gunakan SVG atau teks.
  
  // Solusi alternatif tanpa FontAwesome:
	displayError(target, error, src) {
	  // Ganti dengan SVG/teks biasa
	  errorEl.innerHTML = `
		<div class="error-ui">
		  <svg>...</svg> // Ikon custom
		  <h3>Error Loading</h3>
		  <p>${error.message}</p>
		  <button>Retry</button>
		</div>
	  `;
	}

- **DOMPurify Version**
  Pastikan versi DOMPurify terbaru untuk perlindungan optimal.

================================================================================
12. CHANGELOG & KREDIT
================================================================================

v1.0 Rilis awal.

Diinspirasi oleh praktik manajemen SPA dan pemuatan konten dinamis yang aman.

================================================================================
AKHIR DOKUMENTASI
================================================================================
					</textarea>
				</div>
			</div>
			<div style="text-align: center; margin: 30px 0;">
				<button id="fullDemo" class="btn" style="padding: 15px 30px; font-size: 1.2rem;">
				<i class="fas fa-bolt"></i> Demo Lengkap
				</button>
			</div>
			<footer>
				<p>Gmooy &copy; 2025 - Solusi untuk Konten Dinamis</p>
				<p>Dijamin bebas masalah element null dan siap untuk produksi</p>
			</footer>
		</div>

    <script>
		// Implementasi fungsi fetchAndFill
		function fetchAndFill(src, targetSelector, options = {}) {
			// Validasi ketat parameter input
			if (typeof src !== 'string' || !src.trim()) {
				throw new TypeError('Parameter src harus berupa string non-kosong');
			}

			if (typeof targetSelector !== 'string' || !targetSelector.trim()) {
				throw new TypeError('Parameter targetSelector harus berupa selector CSS yang valid');
			}

			// Konfigurasi default
			const config = {
				position: 'replace',
				relativeTo: null,
				runScripts: false,
				sanitize: true,
				sanitizerOptions: {
					ADD_TAGS: ['safe-custom-element'],
					FORBID_TAGS: ['script', 'iframe', 'object', 'embed'],
					FORBID_ATTR: ['onload', 'onerror', 'onclick'],
					ADD_ATTR: ['data-safe-attr']
				},
				cache: 'memory',
				maxRetries: 2,
				retryDelay: 1000,
				timeout: 30000,
				signal: null,
				...options
			};

			// AbortController untuk manajemen lifecycle
			const controller = new AbortController();
			const abortSignal = config.signal || controller.signal;

			// State management
			let observer, timeoutId, isFilled = false,
				retryCount = 0;
			const EVENT_PREFIX = 'fetchandfill:';

			// Event dispatching
			function dispatchEvent(eventName, detail) {
				const event = new CustomEvent(EVENT_PREFIX + eventName, {
					detail
				});
				document.dispatchEvent(event);
			}

			// Cleanup resources
			function cleanup() {
				observer?.disconnect();
				clearTimeout(timeoutId);
				if (!config.signal) controller.abort();
				dispatchEvent('cleanup', {
					src,
					targetSelector
				});
			}

			// Validasi selector
			function validateSelector(selector) {
				try {
					if (selector) {
						document.createDocumentFragment().querySelector(selector);
					}
					return true;
				} catch {
					throw new Error(`Selector tidak valid: "${selector}"`);
				}
			}

			// Main processing
			async function proceedFill(target) {
				if (isFilled) return;
				isFilled = true;

				try {
					validateSelector(targetSelector);
					validateSelector(config.relativeTo || '');

					dispatchEvent('start', {
						src,
						target,
						config
					});

					let html = null;
					const cacheKey = `cache:${src}`;

					// Cek cache
					if (config.cache !== 'none') {
						if (config.cache === 'memory' && window.fetchCache?.has(cacheKey)) {
							html = window.fetchCache.get(cacheKey);
							dispatchEvent('cachehit', {
								src,
								cacheType: 'memory'
							});
						} else if (config.cache === 'session') {
							const cached = sessionStorage.getItem(cacheKey);
							if (cached) {
								html = cached;
								dispatchEvent('cachehit', {
									src,
									cacheType: 'session'
								});
							}
						}
					}

					// Fetch jika tidak ada di cache
					if (!html) {
						const startTime = performance.now();

						const response = await fetchWithRetry(
							src,
							abortSignal,
							config.maxRetries,
							config.retryDelay
						);

						if (!response.ok) throw new Error(`HTTP ${response.status}`);

						html = await response.text();
						const duration = performance.now() - startTime;

						// Simpan ke cache
						if (config.cache === 'memory') {
							if (!window.fetchCache) window.fetchCache = new Map();
							window.fetchCache.set(cacheKey, html);
						} else if (config.cache === 'session') {
							try {
								sessionStorage.setItem(cacheKey, html);
							} catch (e) {
								console.warn('Session storage full, cache not saved');
							}
						}

						dispatchEvent('fetch', {
							src,
							duration,
							size: html.length
						});
					}

					// Sanitasi HTML
					let sanitizedHtml = html;
					if (config.sanitize) {
						if (typeof DOMPurify !== 'undefined') {
							sanitizedHtml = DOMPurify.sanitize(html, config.sanitizerOptions);
						} else {
							sanitizedHtml = fallbackSanitize(html);
							dispatchEvent('fallbacksanitize', {
								src
							});
						}
					}

					// Parse dan siapkan konten
					const doc = new DOMParser().parseFromString(sanitizedHtml, 'text/html');
					const fragment = document.createDocumentFragment();

					while (doc.body.firstChild) {
						fragment.appendChild(doc.body.firstChild);
					}

					// Penempatan konten
					handlePosition(target, fragment, config.position, config.relativeTo);

					// Jalankan script jika diizinkan
					if (config.runScripts) {
						reinitScripts(target, config.sanitize);
					}

					dispatchEvent('success', {
						src,
						target,
						fragment
					});

				} catch (err) {
					if (err.name !== 'AbortError') {
						console.error(`[fetchAndFill] Error loading "${src}"`, err);
						dispatchEvent('error', {
							src,
							target,
							error: err
						});

						// Fallback UI untuk error
						if (config.position === 'replace') {
							displayError(target, err, src);
						}
					}
				}
			}

			// Implementasi fetch dengan retry
			async function fetchWithRetry(url, signal, maxRetries, retryDelay) {
				try {
					const response = await fetch(url, {
						signal
					});

					if (response.ok) return response;

					if (response.status >= 500 && retryCount < maxRetries) {
						throw new Error(`HTTP ${response.status}`);
					}

					return response;
				} catch (err) {
					if (retryCount < maxRetries) {
						retryCount++;
						const delay = retryDelay * Math.pow(2, retryCount);

						dispatchEvent('retry', {
							src,
							retryCount,
							delay
						});

						await new Promise(res => setTimeout(res, delay));
						return fetchWithRetry(url, signal, maxRetries, retryDelay);
					}
					throw err;
				}
			}

			// Fallback sanitizer jika DOMPurify tidak tersedia
			function fallbackSanitize(html) {
				const temp = document.createElement('div');
				temp.innerHTML = html;

				// Hapus elemen berbahaya
				const forbidden = ['script', 'iframe', 'object', 'embed', 'form', 'link'];
				forbidden.forEach(tag => {
					temp.querySelectorAll(tag).forEach(el => el.remove());
				});

				// Hapus atribut berbahaya
				temp.querySelectorAll('*').forEach(el => {
					const attrs = el.attributes;
					for (let i = attrs.length - 1; i >= 0; i--) {
						const attr = attrs[i];
						if (attr.name.startsWith('on') ||
							(attr.name === 'src' && /^javascript:/i.test(attr.value)) ||
							(attr.name === 'href' && /^javascript:/i.test(attr.value)) ||
							(attr.name === 'style' && /expression|javascript/i.test(attr.value))) {
							el.removeAttribute(attr.name);
						}
					}
				});

				return temp.innerHTML;
			}

			// Error handling UI
			function displayError(target, error, src) {
				const errorEl = document.createElement('div');
				errorEl.className = 'fetch-fill-error';
				errorEl.innerHTML = `
							<div style="text-align:center; padding:30px;">
								<i class="fas fa-exclamation-triangle" style="font-size:3rem;color:#f72585;"></i>
								<h3 style="margin:15px 0;color:#dc3545;">Gagal Memuat Konten</h3>
								<p>${error.message}</p>
								<p style="font-size:0.9rem;margin-top:10px;color:#6c757d;">Source: ${src}</p>
								<button class="btn" style="margin-top:20px;background:var(--danger);">
									<i class="fas fa-redo"></i> Coba Lagi
								</button>
							</div>
						`;

				errorEl.querySelector('.btn').addEventListener('click', () => {
					errorEl.remove();
					isFilled = false;
					retryCount = 0;
					proceedFill(target);
				});

				target.replaceChildren(errorEl);
			}

			// Position handling logic
			function handlePosition(target, fragment, position, relativeTo) {
				switch (position) {
					case 'replace':
						target.replaceChildren(fragment);
						break;
					case 'append':
						target.appendChild(fragment);
						break;
					case 'prepend':
						target.prepend(fragment);
						break;
					case 'before':
					case 'after':
						if (!relativeTo) throw new Error('relativeTo required for before/after');
						const ref = target.querySelector(relativeTo);
						if (ref) {
							ref[position](fragment);
						} else {
							console.warn(`Reference not found: ${relativeTo} - using append`);
							target.appendChild(fragment);
						}
						break;
					default:
						throw new Error(`Invalid position: ${position}`);
				}
			}

			// Reinitialize scripts dengan penanganan khusus
			function reinitScripts(container, isSanitized) {
				container.querySelectorAll('script').forEach(oldScript => {
					// Skip external scripts jika disanitasi
					if (isSanitized && oldScript.src) {
						console.warn('Skipping external script for security');
						return;
					}

					const newScript = document.createElement('script');

					// Copy attributes
					Array.from(oldScript.attributes).forEach(attr => {
						// Skip event attributes jika disanitasi
						if (!isSanitized || !attr.name.startsWith('on')) {
							newScript.setAttribute(attr.name, attr.value);
						}
					});

					// Copy content (hanya untuk inline scripts)
					if (!oldScript.src) {
						newScript.textContent = oldScript.textContent;
					}

					// Replace dengan penanganan error
					try {
						oldScript.replaceWith(newScript);
					} catch (err) {
						console.error('Script replacement error', err);
					}
				});
			}

			// Observer callback
			function mutationCallback() {
				const target = document.querySelector(targetSelector);
				if (target && !isFilled) {
					cleanup();
					proceedFill(target);
				}
			}

			// Eksekusi awal
			try {
				validateSelector(targetSelector);

				const target = document.querySelector(targetSelector);
				if (target) {
					proceedFill(target);
				} else {
					// Setup observer
					observer = new MutationObserver(mutationCallback);
					observer.observe(document.documentElement, {
						childList: true,
						subtree: true,
						attributeFilter: ['id', 'class']
					});

					// Timeout fallback
					timeoutId = setTimeout(() => {
						if (!isFilled) {
							cleanup();
							const err = new Error(`Target element not found: ${targetSelector}`);
							dispatchEvent('error', {
								src,
								error: err
							});
							throw err;
						}
					}, config.timeout);

					// Handle abort signal
					abortSignal.addEventListener('abort', cleanup);
				}
			} catch (err) {
				dispatchEvent('error', {
					src,
					error: err
				});
				throw err;
			}

			return {
				abort: cleanup,
				on: (event, handler) => {
					const eventName = EVENT_PREFIX + event;
					document.addEventListener(eventName, handler);
					return () => document.removeEventListener(eventName, handler);
				}
			};
		}

		// Demo Functions
		document.querySelectorAll('.tab').forEach(tab => {
			tab.addEventListener('click', function () {
				// Remove active class from all tabs
				document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
				// Hide all tab content
				document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

				// Add active class to clicked tab
				this.classList.add('active');

				// Show corresponding content
				const tabName = this.getAttribute('data-tab');
				document.getElementById(`${tabName}-content`).classList.add('active');
			});
		});

		// Clipboard functionality
		// Clipboard functionality
		document.querySelectorAll('.copy-btn').forEach(btn => {
			btn.addEventListener('click', function () {
				const targetId = this.getAttribute('data-clipboard-target');
				const textarea = document.querySelector(targetId);
				if (textarea) {
					navigator.clipboard.writeText(textarea.value)
						.then(() => {
							const originalHTML = this.innerHTML;
							this.innerHTML = '<i class="fas fa-check"></i> Disalin!';
							setTimeout(() => {
								this.innerHTML = originalHTML;
							}, 2000);
						})
						.catch(err => {
							console.error('Gagal menyalin:', err);
							alert('Gagal menyalin teks.');
						});
				}
			});
		});

		// Demo content loading
		document.getElementById('loadDemo').addEventListener('click', function () {
			const demoContent = document.getElementById('demoContent');
			demoContent.classList.remove('error');
			demoContent.classList.add('loaded');

			// Clear previous content
			demoContent.innerHTML = `
						<div class="demo-placeholder">
							<div class="spinner" style="font-size:3rem;margin-bottom:20px;">
								<i class="fas fa-spinner fa-spin"></i>
							</div>
							<p>Memuat konten demo...</p>
						</div>
					`;

			// Clear event log
			const eventLog = document.getElementById('eventLog');
			eventLog.innerHTML = '';

			// Function to log events
			function logEvent(message, type = 'info') {
				const now = new Date();
				const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

				const eventEntry = document.createElement('div');
				eventEntry.className = 'event-entry';
				eventEntry.innerHTML = `
							<span class="event-time">${timeString}</span>
							<span class="event-${type}">${message}</span>
						`;

				eventLog.prepend(eventEntry);
			}

			// Listen to events
			document.addEventListener('fetchandfill:start', (e) => {
				logEvent(`Memulai pemuatan: ${e.detail.src}`, 'info');
			});

			document.addEventListener('fetchandfill:fetch', (e) => {
				logEvent(`Konten diambil (${e.detail.size} bytes, ${Math.round(e.detail.duration)}ms)`, 'success');
			});

			document.addEventListener('fetchandfill:success', (e) => {
				logEvent(`Konten berhasil dimuat di ${e.detail.target.id}`, 'success');

				// Simulate content display
				setTimeout(() => {
					demoContent.innerHTML = `
								<div style="text-align:center; padding:20px;">
									<i class="fas fa-check-circle" style="font-size:4rem;color:#4cc9f0;"></i>
									<h3 style="margin:15px 0;color:#4361ee;">Konten Berhasil Dimuat!</h3>
									<p>Ini adalah konten demo yang dimuat secara dinamis</p>
									<p style="margin-top:15px;">
										<button class="btn" style="background:var(--success);">
											<i class="fas fa-thumbs-up"></i> Tombol Demo
										</button>
									</p>
								</div>
							`;
				}, 800);
			});

			// Load demo content
			fetchAndFill('#demoContent', '#demoContent', {
				position: 'replace',
				sanitize: false,
				runScripts: true
			});
		});

		// Error demo
		document.getElementById('loadError').addEventListener('click', function () {
			const errorContent = document.getElementById('errorContent');
			errorContent.classList.remove('loaded');
			errorContent.classList.add('error');

			// Clear previous content
			errorContent.innerHTML = `
						<div class="demo-placeholder">
							<div class="spinner" style="font-size:3rem;margin-bottom:20px;">
								<i class="fas fa-spinner fa-spin"></i>
							</div>
							<p>Memuat konten error...</p>
						</div>
					`;

			// Clear event log
			const errorLog = document.getElementById('errorLog');
			errorLog.innerHTML = '';

			// Function to log events
			function logEvent(message, type = 'info') {
				const now = new Date();
				const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

				const eventEntry = document.createElement('div');
				eventEntry.className = 'event-entry';
				eventEntry.innerHTML = `
							<span class="event-time">${timeString}</span>
							<span class="event-${type}">${message}</span>
						`;

				errorLog.prepend(eventEntry);
			}

			// Listen to events
			document.addEventListener('fetchandfill:start', (e) => {
				logEvent(`Memulai pemuatan: ${e.detail.src}`, 'info');
			});

			document.addEventListener('fetchandfill:retry', (e) => {
				logEvent(`Percobaan ulang (${e.detail.retryCount}) dalam ${e.detail.delay}ms`, 'info');
			});

			document.addEventListener('fetchandfill:error', (e) => {
				logEvent(`Error: ${e.detail.error.message}`, 'error');
			});

			// Load error content
			fetchAndFill('non-existent-file.html', '#errorContent', {
				position: 'replace',
				maxRetries: 2
			});
		});

		// Load all demo
		document.getElementById('fullDemo').addEventListener('click', function () {
			window.location.href = './demo';
		});

		document.getElementById('open-btn').addEventListener('click', function () {
			window.open('./demo/FetchAndFill-Module.js', '_blank');
		});
		document.getElementById('download-btn').addEventListener('click', function () {
			const link = document.createElement('a');
			link.href = './demo/FetchAndFill-Module.js';
			link.download = 'FetchAndFill-Module.js';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		});
    </script>
</body>
</html>