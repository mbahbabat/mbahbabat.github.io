<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<!-- Mobile & Theme -->		
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="theme-color" content="#ff6666">
		<meta name="msapplication-navbutton-color" content="#ff6666">
		<meta name="apple-mobile-web-app-status-bar-style" content="#ff6666">	
		<!-- Author -->	
		<meta name="author" content="Gmooy">
		<!-- Primary Meta Tags -->
		<title>Bulk Gmail Checker â€“ Validate 1000+ Gmails in Seconds | 99% Accuracy</title>
		<meta name="title" content="Bulk Gmail Checker â€“ Validate 1000+ Gmails in Seconds | 99% Accuracy">
		<meta name="description" content="Free, fast, and secure bulk Gmail validator. Check if Gmail accounts are Live, Verified, Disabled, or Unregistered. Supports copy, download, history, and API key management. We are a trusted Gmail validation API provider.">
		<!-- Open Graph / Facebook -->
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://mbahbabat.github.io/en/bulk-gmail-checker/execute/">
		<meta property="og:title" content="Bulk Gmail Checker â€“ Validate 1000+ Gmails in Seconds">
		<meta property="og:description" content="Free, fast, and secure bulk Gmail validator. Check if Gmail accounts are Live, Verified, Disabled, or Unregistered. Supports copy, download, history, and API key management. We are a trusted Gmail validation API provider.">
		<meta property="og:image" content="https://mbahbabat.github.io/en/bulk-gmail-checker/assets/image/dragon-bulk-gmail-checker-logo.webp">
		<meta property="og:site_name" content="Bulk Gmail Checker">
		<!-- Twitter -->
		<meta property="twitter:card" content="summary_large_image">
		<meta property="twitter:url" content="https://mbahbabat.github.io/en/bulk-gmail-checker/execute/">
		<meta property="twitter:title" content="Bulk Gmail Checker â€“ Validate 1000+ Gmails in Seconds">
		<meta property="twitter:description" content="Free, fast, and secure bulk Gmail validator. Check if Gmail accounts are Live, Verified, Disabled, or Unregistered. Supports copy, download, history, and API key management. We are a trusted Gmail validation API provider.">
		<meta property="twitter:image" content="https://mbahbabat.github.io/en/bulk-gmail-checker/assets/image/dragon-bulk-gmail-checker-logo.webp">
		<!-- Canonical & Misc -->
		<link rel="canonical" href="https://mbahbabat.github.io/en/bulk-gmail-checker/">
		<meta name="author" content="Gmooy">
		<meta name="robots" content="index, follow">
		<meta name="keywords" content="gmail checker, bulk gmail checker, gmail validation, email tools, email checker, email validation, email verification, bulk email validator, gmail live checker, gmail verification tool, check gmail account, gmail status checker, free gmail validator">
		<!-- favicon -->
		<link rel="shortcut icon" href="https://mbahbabat.github.io/en/bulk-gmail-checker/assets/image/dragon-bulk-gmail-checker-icon.ico" type="image/webp">
		<!-- Language -->
		<link rel="alternate" hreflang="en" href="https://mbahbabat.github.io/en/bulk-gmail-checker/execute/">
		<link rel="alternate" hreflang="id-ID" href="https://mbahbabat.github.io/id/bulk-gmail-checker/execute/">
		<link rel="alternate" hreflang="x-default" href="https://mbahbabat.github.io/en/bulk-gmail-checker/execute/">
		
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
		<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
		<script type="application/ld+json">
		{
		  "@context": "https://schema.org",
		  "@type": "Organization",
		  "name": "Gmooy",
		  "url": "https://mbahbabat.github.io/en/bulk-gmail-checker/execute/",
		  "logo": "https://mbahbabat.github.io/en/bulk-gmail-checker/assets/image/dragon-bulk-gmail-checker-logo.webp",
		  "description": "Free, fast, and secure bulk Gmail validator. Check if Gmail accounts are Live, Verified, Disabled, or Unregistered. Supports copy, download, history, and API key management. No registration required. we are gmail validation API provider",
		  "sameAs": [
			"https://t.me/GMAIL_GLOBAL_CHAT"
		  ]
		}
		</script>		
		<style>		
			/* Screen - Low Config */
			/* Handle width */
			@media(min-width:1025px) {
				main {
					max-width: 900px;
				}
			}

			@media(max-width:1024px) {
				body {
					zoom: 90%;
				}
			}

			@media(max-width:768px) {
				body {
					zoom: 75%;
				}
			}

			@media(max-width:500px) {
				body {
					zoom: 50%;
				}
			}

			@media(max-width:300px) {
				body {
					zoom: 30%;
				}
			}

			@media(max-width:200px) {
				body {
					zoom: 20%;
				}
			}

			@media(max-width:100px) {
				body {
					zoom: 10%;
				}
			}

			/* Handle Height */
			@media(max-height:700px) {
				body {
					zoom: 90%;
				}
			}

			@media(max-height:700px) {
				body {
					zoom: 75%;
				}
			}

			@media(max-height:550px) {
				body {
					zoom: 50%;
				}
			}

			@media(max-height:350px) {
				body {
					zoom: 30%;
				}
			}

			@media(max-height:200px) {
				body {
					zoom: 20%;
				}
			}

			@media(max-height:150px) {
				body {
					zoom: 15%;
				}
			}

			@media(max-height:100px) {
				body {
					zoom: 10%;
				}
			}

			/* Global*/
			:root {
				/* Menggunakan warna yang terinspirasi naga: merah tua, oranye menyala, dan abu-abu gelap */
				--primary-red: #8B0000;
				/* Dark Red */
				--secondary-orange: #FF4500;
				/* OrangeRed */
				--dark-grey: #1a1a1a;
				/* Very dark grey, almost black */
				--text-color: #f0f0f0;
				/* Light grey for text for better contrast */
				--border-color: var(--secondary-orange);
				/* Orange border for focus/accent */
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				font-family: 'Roboto Mono', monospace;
				-webkit-tap-highlight-color: transparent;
			}

			*:before,
			*:after {
				box-sizing: inherit;
			}

			a {
				text-decoration: none;
				background-color: transparent;
			}

			mark {
				background: var(--secondary-orange);
				/* Orange highlight */
				color: var(--dark-grey);
			}

			img {
				border-style: none;
			}

			.btn {
				padding: 10px 20px;
				border: 0;
				border-radius: 8px;
				cursor: pointer;
				font-size: 1em;
				transition: background-color .3s, transform .2s, box-shadow .3s;
				text-transform: uppercase;
				font-family: 'Orbitron', sans-serif;
				letter-spacing: 1px;
				background-color: var(--primary-red);
				/* Red button */
				color: var(--text-color);
				box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
			}

			.btn:disabled {
				cursor: not-allowed;
				filter: brightness(50%);
				transform: none;
				box-shadow: none
			}

			.btn:hover:not(:disabled) {
				background: var(--secondary-orange);
				/* Orange on hover */
				transform: translateY(-2px);
				box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6)
			}

			.btn-large {
				padding: 15px 30px;
				font-size: 18px;
			}

			.hidden {
				display: none !important;
			}

			.active {
				border: none !important;
				animation: fire 0.5s infinite alternate;
			}

			.button-container {
				display: flex;
				gap: 10px;
				justify-content: center;
				flex-wrap: wrap;
			}

			.background-glow {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				width: 100%;
				height: 100%;
				/* Menggunakan gradien radial yang lebih gelap dan merah/oranye */
				background: radial-gradient(circle, rgba(26, 26, 26, 1) 0%, rgba(139, 0, 0, 0.8) 60%, rgba(26, 26, 26, 1) 100%);
				animation: pulseGlow 5s infinite alternate ease-in-out;
				z-index: -1;
				pointer-events: none;
				border-radius: 10%;
			}

			::-webkit-scrollbar {
				width: 8px
			}

			::-webkit-scrollbar-track {
				background: rgba(255, 255, 255, 0.05);
				border-radius: 10px
			}

			::-webkit-scrollbar-thumb {
				background-color: rgba(167, 129, 255, 0.2);
				border-radius: 10px;
				border: 1px solid rgba(77, 210, 255, 0.7)
			}

			::-webkit-scrollbar-thumb:hover {
				background-color: rgba(175, 134, 252, 0.7)
			}

			/* CORE */
			body {
				position: absolute;
				width: 100%;
				height: 100%;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				gap: 15px;
				padding: 15px;
				overflow: hidden;
				color: var(--text-color);
				/* Latar belakang gambar naga */
				background-size: cover;
				background-color: var(--dark-grey);
				/* Fallback color */
				scrollbar-width: 8px;
				scrollbar-color: rgba(255, 0, 0, 0.5) rgba(255, 255, 255, 0.05)
			}

			header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				padding: 15px;
				width: 100%;
				height: 100px;
				display: flex;
				text-shadow: 0 0 10px rgba(255, 69, 0, 0.8);
				/* Orange glow for header text */
			}

			.header-section {
				display: flex;
			}

			.center-header-section {
				flex: 1;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
			}

			.right-header-section {
				display: flex;
				justify-content: right;
				align-items: center;
				gap: 15px;
			}

			.right-header-section button {
				border-radius: 50%;
				width: 50px;
				height: 50px;
				padding: 0;
				font-size: 1.6em;
			}

			.header-button {
				box-shadow: 0 0 20px var(--primary-red), 0 0 40px var(--secondary-orange);
			}

			h1 {
				text-align: center;
				font-family: 'Orbitron', sans-serif;
				color: var(--secondary-orange);
				/* Orange for main title */
			}

			header p {
				text-align: center;
			}

			main {
				flex: 1;
				width: 100%;
				display: flex;
				flex-direction: column;
				gap: 15px;
				padding: 15px;
				overflow: hidden;
				border: 1px solid var(--border-color);
				border-radius: 15px;
				background: rgba(26, 26, 26, 0.8);
				/* Darker, slightly transparent background for main content */
				box-shadow: 0 0 20px rgba(255, 69, 0, 0.4);
				/* Subtle orange shadow */
			}

			footer {
				width: 100%;
				height: 50px;
				display: flex;
				justify-content: center;
				align-items: center;
				color: rgba(240, 240, 240, 0.7);
				/* Slightly subdued footer text */
			}

			/* INPUT */
			.input-section {
				flex: 1;
				display: flex;
				flex-direction: column;
				gap: 15px;
				width: 100%;
				overflow: hidden;
				position: relative;
			}

			.input-section-header {
				display: flex;
				align-items: center;
				gap: 15px;
			}

			.input-section-header h3 {
				flex: 1;
				font-family: 'Orbitron', sans-serif;
				color: var(--secondary-orange);
				/* Orange for section titles */
			}

			.textarea-container {
				flex: 1;
				display: flex;
				overflow: hidden;
			}

			.line-numbers {
				height: 100%;
				min-width: 50px;
				overflow: hidden;
				display: flex;
				flex-direction: column;
				align-items: flex-end;
				pointer-events: none;
				user-select: none;
				border: 1px solid var(--border-color);
				border-right: 0;
				font-size: 1em;
				padding: 15px;
				background: rgba(0, 0, 0, 0.6);
				/* Darker background for line numbers */
				color: rgba(240, 240, 240, 0.6);
			}

			#email-input {
				flex: 1;
				border: none;
				outline: none;
				resize: none;
				padding: 15px;
				font-size: 1em;
				border: 1px solid var(--border-color);
				white-space: pre;
				padding-bottom: 0;
				background: rgba(0, 0, 0, 0.7);
				/* Darker background for textarea */
				color: var(--text-color);
			}

			.input-button {
				display: grid;
				grid-template-columns: 1fr 1fr;
				/* Membuat 2 kolom sama lebar */
				gap: 10px;
				/* Optional: mengatur jarak antar tombol */
			}

			/* OVERLAY & PROGRESS */
			.progress-overlay {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(255, 0, 0, 0.2);
				/* Darker, more opaque overlay */
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				z-index: 1000;
				pointer-events: none;
				user-select: none;
			}

			.donut-chart-container {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 30px;
			}

			.donut-chart {
				position: relative;
				width: 180px;
				height: 180px;
				border-radius: 50%;
				background: conic-gradient(var(--primary-red) 0% 0%, #333 0% 100%);
				/* Red progress */
				display: flex;
				justify-content: center;
				align-items: center;
				box-shadow:
					0 0 15px rgba(255, 69, 0, 0.7),
					/* Orange glow */
					0 0 30px rgba(255, 69, 0, 0.5),
					0 0 50px rgba(255, 69, 0, 0.3),
					inset 0 0 10px rgba(255, 255, 255, 0.2);
			}

			.donut-chart::before {
				content: '';
				position: absolute;
				width: 140px;
				height: 140px;
				border-radius: 50%;
				background-color: var(--dark-grey);
				/* Dark grey inner circle */
				box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
			}

			.progress-text {
				position: relative;
				color: var(--text-color);
				font-size: 2.2em;
				font-weight: bold;
				z-index: 1;
				text-shadow: 0 0 8px rgba(255, 69, 0, 0.8);
				/* Orange glow for progress text */
				font-family: 'Orbitron', sans-serif;
			}

			/* OUTPUT */
			.output-section {
				flex: 1;
				min-height: 300px;
				display: flex;
				flex-direction: column;
				gap: 15px;
				width: 100%;
				overflow-x: visible;
				position: relative;
			}

			.output-button {
				display: flex;
				flex-direction: column;
				gap: 50px;
				justify-content: center;
				align-items: center;
			}

			.result-button-container {
				width: 100%;
				display: grid;
				grid-template-columns: 1fr 1fr;
				/* Membuat 2 kolom sama lebar */
				gap: 10px;
				/* Optional: mengatur jarak antar tombol */
			}

			.result-button {
				display: flex;
				flex-direction: column;
				gap: 10px;
				justify-content: center;
				align-items: center;
				font-size: 1.3em;
				font-weight: bold;
			}

			.output-section h3 {
				text-align: center;
				color: var(--secondary-orange);
				/* Orange for section titles */
			}

			.result-container {
				display: flex;
				flex-direction: column;
				gap: 15px;
				height: 100%;
				min-height: 200px;
				overflow-y: auto;
				border: 1px solid var(--border-color);
				background: rgba(0, 0, 0, 0.6);
				/* Darker background for results */
				position: relative;
			}

			.result-list-container {
				flex: 1;
				overflow-y: auto;
				border: 1px solid var(--border-color);
				padding: 15px;
				background: rgba(0, 0, 0, 0.5);
				/* Slightly lighter dark for inner list */
			}

			.result-item {
				padding: 8px 5px;
				border-bottom: 1px solid rgba(240, 240, 240, 0.2);
				/* Lighter border for list items */
				display: flex;
				align-items: baseline;
				gap: 10px;
				height: 35px;
				white-space: nowrap
			}

			.result-item:last-child {
				border-bottom: none;
			}

			/* Status colors - adjusted for dragon theme */
			.status-live {
				color: #00FF7F;
				/* Bright green for live */
			}

			.status-verify {
				color: #FFD700;
				/* Gold for verify */
			}

			.status-disabled {
				color: #FF6347;
				/* Tomato red for disabled */
			}

			.status-unregistered {
				color: #1E90FF;
				/* Dodger blue for unregistered */
			}

			.status-error {
				color: #FF8C00;
				/* Dark orange for error */
			}

			.filter-button-group {
				display: grid;
				grid-template-columns: repeat(3, 1fr);
				grid-auto-rows: 1fr;
				gap: 5px;
			}

			.filter-btn {
				padding: 5px;
				;
				margin: 0;
				border: 1px solid red;
				border-radius: 15px;
				font-size: 0.8em;
				background: none;
			}

			.filter-btn[data-filter="live"] .counter {
				color: #00FF7F;
			}

			.filter-btn[data-filter="verify"] .counter {
				color: #FFD700;
			}

			.filter-btn[data-filter="disabled"] .counter {
				color: #FF6347;
			}

			.filter-btn[data-filter="unregistered"] .counter {
				color: #1E90FF;
			}

			.filter-btn[data-filter="error"] .counter {
				color: #FF8C00;
			}

			/* CONTROLS SECTION */
			.controls-section {
				display: flex;
				flex-direction: column;
				gap: 15px;
				width: 100%;
				overflow: hidden;
				position: relative;
			}

			.clear-errors-btn {
				animation: blink-animation 1s infinite;
			}

			.system-info-container {
				display: flex;
				flex-direction: column;
				justify-content: center;
				gap: 15px;
				height: 200px;
				padding: 15px;
				border: 1px solid var(--border-color);
				background: rgba(0, 0, 0, 0.6);
				/* Dark background for system info */
			}

			.system-info {
				min-width: 30px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.2em;
				color: var(--border-color);
			}

			.system-info p {
				text-align: center;
				white-space: nowrap;
				/* Mencegah teks berpindah ke baris baru */
				overflow: hidden;
				/* Menyembunyikan teks yang meluap dari wadahnya */
				text-overflow: ellipsis;
			}

			.error-info,
			.api-stats {
				flex: 1;
				border: 1px solid var(--border-color);
				overflow: hidden;
				padding: 0 15px 0 15px;
				font-size: 1em;
				background: rgba(0, 0, 0, 0.5);
				/* Slightly lighter dark for errors/stats */
				overflow-y: auto;
			}

			.api-stats {
				padding: 15px;
			}

			.stats-grid {
				flex: 1;
				display: grid;
				grid-template-columns: repeat(3, 1fr);
				grid-auto-rows: 1fr;
				gap: 10px;
			}

			.stat-item {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				text-align: center;
				padding: 5px;
				color: #d9d9d9;
				broder: 1px solid red;
				border-radius: 5px;
				font-size: 0.9em;
				transition: background-color .3s, transform .2s, box-shadow .3s;
				box-shadow: 0 0 5px var(--primary-red), 0 0 10px var(--secondary-orange);
			}

			.stat-item #countdown {
				color: red;
			}

			.error-list {
				width: 100%;
				height: 100%;
				overflow-y: auto;
				color: var(--text-color);
			}

			/* Specific error message colors */
			.error-list p {
				margin: 5px 0;
			}

			.error-list p span[style*='color:red'] {
				color: var(--primary-red) !important;
			}

			.error-list p span[style*='color:orange'] {
				color: var(--secondary-orange) !important;
			}

			.error-list p span[style*='color:blue'] {
				color: #1E90FF !important;
				/* Dodger blue for domain errors */
			}

			.error-list p span[style*='color:purple'] {
				color: #DA70D6 !important;
				/* Orchid for duplicate emails */
			}

			@keyframes pulseGlow {
				0% {
					transform: translate(-50%, -50%) scale(1.1);
					opacity: .6;
					box-shadow: 0 0 20px var(--primary-red), 0 0 40px var(--secondary-orange);
				}

				100% {
					transform: translate(-50%, -50%) scale(10);
					opacity: .8;
					box-shadow: 0 0 50px var(--primary-red), 0 0 100px var(--secondary-orange);
				}
			}

			/* MODAL STYLES */
			.modal {
				display: flex;
				align-items: center;
				justify-content: center;
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.3);
				z-index: 10000;
				overflow: hidden;
			}

			.modal-content {
				position: relative;
				background-color: var(--dark-grey);
				margin: 2% auto;
				padding: 0;
				border: 2px solid var(--border-color);
				border-radius: 15px;
				box-shadow: 0 0 30px rgba(255, 69, 0, 0.6);
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}

			/* Desktop */
			@media screen and (min-width: 1025px) {
				.modal-content {
					width: 900px;
					height: 95%;
				}
			}

			/* Mobile */
			@media screen and (max-width: 1024px) {
				.modal-content {
					width: 100% !important;
					height: 100% !important;
				}
			}

			.modal-header {
				padding: 20px;
				border-bottom: 1px solid var(--border-color);
				background: rgba(0, 0, 0, 0.6);
				flex-shrink: 0;
			}

			.modal-header h2 {
				font-family: 'Orbitron', sans-serif;
				color: var(--secondary-orange);
				text-align: center;
				margin: 0;
				text-shadow: 0 0 10px rgba(255, 69, 0, 0.8);
			}

			.modal-body {
				flex: 1;
				overflow-y: auto;
				padding: 20px;
				display: flex;
				flex-direction: column;
				gap: 20px;
			}

			.modal-footer {
				padding: 15px;
				border-top: 1px solid var(--border-color);
				background: rgba(0, 0, 0, 0.6);
				display: flex;
				justify-content: center;
				flex-shrink: 0;
			}

			.close-modal {
				padding: 10px 30px;
				font-size: 1.1em;
			}

			/* API Key Section */
			.api-key-section {
				border: 1px solid var(--border-color);
				border-radius: 10px;
				padding: 15px;
				background: rgba(0, 0, 0, 0.5);
			}

			.api-key-section h3 {
				color: var(--secondary-orange);
				margin-bottom: 10px;
				font-family: 'Orbitron', sans-serif;
			}

			.api-key-display {
				display: flex;
				align-items: center;
				gap: 10px;
				margin-bottom: 15px;
			}

			.api-key-value {
				flex: 1;
				padding: 10px;
				background: rgba(0, 0, 0, 0.7);
				border: 1px solid var(--border-color);
				border-radius: 5px;
				font-family: 'Roboto Mono', monospace;
				color: var(--text-color);
				word-break: break-all;
			}

			.copy-api-key {
				padding: 10px 15px;
				font-size: 0.9em;
			}

			/* Stats Section */
			.stats-section {
				border: 1px solid var(--border-color);
				border-radius: 10px;
				padding: 15px;
				background: rgba(0, 0, 0, 0.5);
			}

			.stats-section h3 {
				color: var(--secondary-orange);
				margin-bottom: 15px;
				font-family: 'Orbitron', sans-serif;
			}

			#modal-stats-container {
				min-height: 200px;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			/* History Section */
			.history-section {
				flex: 1;
				height: 500px;
				min-height: 500px;
				display: flex;
				flex-direction: column;
				border: 1px solid var(--border-color);
				border-radius: 10px;
				padding: 15px;
				background: rgba(0, 0, 0, 0.5);
			}

			.history-section h3 {
				color: var(--secondary-orange);
				margin-bottom: 15px;
				font-family: 'Orbitron', sans-serif;
			}

			.history-placeholder {
				text-align: center;
				padding: 40px 20px;
				color: rgba(240, 240, 240, 0.6);
				font-style: italic;
			}

			/* History List Styles */
			.history-list {
				flex: 1;
				overflow-y: auto;
				border: 1px solid var(--border-color);
				border-radius: 5px;
				background: rgba(0, 0, 0, 0.3);
			}

			.history-item {
				display: flex;
				justify-content: space-between;
				gap: 15px;
				align-items: center;
				padding: 10px 15px;
				border-bottom: 1px solid rgba(255, 69, 0, 0.3);
				transition: background-color 0.3s;
			}

			.history-item:last-child {
				border-bottom: none;
			}

			.history-item:hover {
				background: rgba(255, 69, 0, 0.1);
			}

			.history-info {
				flex: 1;
			}

			.history-filename {
				font-weight: bold;
				color: var(--text-color);
				margin-bottom: 5px;
				font-family: 'Roboto Mono', monospace;
			}

			.history-meta {
				font-size: 0.85em;
				color: rgba(240, 240, 240, 0.7);
				display: flex;
				gap: 15px;
			}

			.history-actions {
				display: flex;
				gap: 5px;
			}

			.history-btn {
				padding: 6px 12px;
				font-size: 0.8em;
				border-radius: 4px;
				cursor: pointer;
				color: white;
			}

			.history-btn.open {
				background: rgba(0, 255, 127, 0.2);
				border: 1px solid #00FF7F;
			}

			.history-btn.copy {
				background: rgba(30, 144, 255, 0.2);
				border: 1px solid #1E90FF;
			}

			.history-btn.download {
				background: rgba(255, 215, 0, 0.2);
				border: 1px solid #FFD700;
			}

			.history-btn.delete {
				background: rgba(255, 69, 0, 0.2);
				border: 1px solid #FF4500;
			}

			.empty-history {
				text-align: center;
				padding: 40px 20px;
				color: rgba(240, 240, 240, 0.6);
				font-style: italic;
			}

			.history-stats {
				display: flex;
				gap: 10px;
				margin-bottom: 15px;
				flex-wrap: wrap;
			}

			.history-stat {
				padding: 5px 10px;
				background: rgba(255, 69, 0, 0.2);
				border-radius: 5px;
				font-size: 0.9em;
			}

			.clear-history-btn {
				margin-top: 10px;
				width: 100%;
				padding: 8px;
				font-size: 0.9em;
			}

			@keyframes blink-animation {
				0% {
					filter: brightness(50%);
				}

				50% {
					filter: brightness(100%);
				}

				100% {
					filter: brightness(50%);
				}
			}

			@keyframes fire {
				0% {
					box-shadow: 0 0 5px #ffcc00, 0 0 15px #ff9900, 0 0 20px #ff6600;
					background: rgba(255, 150, 150, 0.2);
				}

				50% {
					box-shadow: 0 0 10px #ffeb3b, 0 0 20px #ff4000, 0 0 25px #e65100;
					background: rgba(255, 0, 0, 0.2);
				}

				100% {
					box-shadow: 0 0 5px #ffcc00, 0 0 15px #ff9900, 0 0 20px #ff6600;
					background: rgba(255, 150, 150, 0.2);
				}
			}		
		</style>
	</head>
	<body>
		<div class="background-glow"></div>
		<!-- HEADER -->
		<header>
			<div class="left-header-section header-section">
			</div>
			<div class="center-header-section header-section">
				<h1>BULK GMAIL CHECKER</h1>
				<p>BULK PROCESSING, INSTANT RESULTS AND 99% ACCURACY</p>
			</div>
			<div class="right-header-section header-section">
				<div class="button-container">
					<button class="btn header-button hidden" id="settings-button" title="Settings">
					<i class="fa-solid fa-gear"></i>
					</button>					
					<button class="btn header-button" id="my-account-button" title="My Account">
					<i class="fa-regular fa-user"></i>
					</button>	
				</div>
			</div>
		</header>
		<!-- MAIN -->
		<main>
			<!-- INPUT -->
			<div class="input-section" id="input-section">
				<div class="input-section-header" id="input-section-header">
					<h3>EMAIL INPUT</h3>
					<div class="button-container">					
						<button class="btn" id="upload-btn">
						<i class="fas fa-upload"></i> UPLOAD TXT
						</button>				
						<input type="file" id="file-input" class="file-input hidden" accept=".txt">	
						<button class="btn" id="paste-btn">
						<i class="fas fa-paste"></i> PASTE
						</button>					
					</div>
				</div>
				<div class="textarea-container">
					<div id="line-numbers" class="line-numbers">1</div>
					<textarea id="email-input" rows="8" placeholder="example1@gmail.com&#10;example2@gmail.com&#10;example3@gmail.com"></textarea>
				</div>
			</div>
			<!-- OUTPUT -->
			<div class="output-section hidden" id="output-section">
				<h3>RESULTS</h3>
				<div class="button-container filter-button-group">
					<button class="btn filter-btn active" data-filter="all">All <span class="counter" id="count-all">(0)</span></button>
					<button class="btn filter-btn" data-filter="live">Live <span class="counter" id="count-live">(0)</span></button>
					<button class="btn filter-btn" data-filter="verify">Ver <span class="counter" id="count-ver">(0)</span></button>
					<button class="btn filter-btn" data-filter="disabled">Disabled <span class="counter" id="count-disabled">(0)</span></button>
					<button class="btn filter-btn" data-filter="unregistered">Unregistered <span class="counter" id="count-unregistered">(0)</span></button>
					<button class="btn filter-btn" data-filter="error">Error <span class="counter" id="count-error">(0)</span></button>
				</div>
				<div class="result-container">
					<div class="result-list-container">
						<div class="result-list" id="result-list">
							<!-- Results will be displayed here -->
						</div>
					</div>
					<div id="progress-overlay" class="progress-overlay hidden">
						<div class="donut-chart-container">
							<div class="donut-chart" id="donut-chart">
								<div class="progress-text" id="progress-text">0%</div>
							</div>
						</div>
					</div>
				</div>
			</div>
			<div class="controls-section" id="controls-section">
				<div class="system-info-container">
					<div class="system-info" id="input-system-info">
						<p id="system-message"> WELCOME </p>
					</div>
					<div class="error-info hidden" id="error-info">
						<div class="error-list" id="error-list"></div>
					</div>
					<div class="api-stats hidden" id="api-stats"></div>
				</div>
				<div class="button-container input-button" id="input-button">
					<button class="btn hidden clear-errors-btn" id="clear-errors-btn">
					<i class="fas fa-bug-slash"></i> FIX INPUT
					</button>				
					<button class="btn" id="clear-input-btn">
					<i class="fas fa-trash"></i> CLEAR INPUT
					</button>											
					<button class="btn" id="execute-btn">
					<i class="fas fa-play"></i> EXECUTE
					</button>				
				</div>
				<div class="button-container hidden" id="stop-button-container">
					<button class="btn btn-large stop-btn" id="stop-execution-btn">
					<i class="fas fa-stop"></i> STOP
					</button>
				</div>
				<div class="button-container output-button hidden" id="output-button">
					<div class="result-button-container">
						<button class="btn result-button" id="copy-btn">
							<p><i class="fas fa-copy"></i> COPY</p>
						</button>
						<button class="btn result-button" id="download-btn">
							<p><i class="fas fa-download"></i> DOWNLOAD (TXT)</p>
						</button>
					</div>
					<div class="reset-button-container">
						<button class="btn" id="reset-btn">
						<i class="fa-solid fa-arrows-rotate"></i> RESET SYSTEM
						</button>						
					</div>
				</div>
			</div>
		</main>
		<!-- FOOTER -->
		<footer>
			<p>Â© 2024 Gmooy | All Rights Reserved</p>
		</footer>
		<!-- INLINE SCRIPTS -->
		<!-- INIT -->
		<script id="INIT-SYSTEM">
			// ========== SELECTOR ==========
			
			//INPUT
			const inputSection = document.getElementById('input-section');
			const emailInput = document.getElementById('email-input');
			const lineNumbers = document.getElementById('line-numbers');
			const pasteBtn = document.getElementById('paste-btn');
			const uploadBtn = document.getElementById('upload-btn');
			const fileInput = document.getElementById('file-input');
			const clearInputBtn = document.getElementById('clear-input-btn');
			const executeBtn = document.getElementById('execute-btn');
			const clearErrorsBtn = document.getElementById('clear-errors-btn');
			const errorInfo = document.getElementById('error-info');
			const errorList = document.getElementById('error-list');
			
			// OUTPUT
			const outputSection = document.getElementById('output-section');
			const resetBtn = document.getElementById('reset-btn');
			const copyBtn = document.getElementById('copy-btn');
			const downloadBtn = document.getElementById('download-btn');
			const filterBtns = document.querySelectorAll('.filter-btn');
			const resultList = document.getElementById('result-list');
			const resultListContainer = document.querySelector('.result-list-container');
			const countAll = document.getElementById('count-all');
			const countLive = document.getElementById('count-live');
			const countVer = document.getElementById('count-ver');
			const countDisabled = document.getElementById('count-disabled');
			const countUnregistered = document.getElementById('count-unregistered');
			const countError = document.getElementById('count-error');
			// -- progress bar --
			const progressOverlay = document.getElementById('progress-overlay');
			const donutChart = document.getElementById('donut-chart');
			const progressText = document.getElementById('progress-text');
			
					
			//CONTROLS
			const inputButtonContainer = document.getElementById('input-button');
			const outputButtonContainer = document.getElementById('output-button');
			const stopButttonContainer = document.getElementById('stop-button-container');
			const stopExecutionBtn = document.getElementById('stop-execution-btn');	
			const systemMessage = document.getElementById('system-message');
			const apiStats = document.getElementById('api-stats');
			
			const myAccountButton = document.getElementById('my-account-button');			
			
			
			const DB_URL = "https://ws-proxy.mbahbabat.workers.dev";
			const SERVER_URL = 'https://gmail-validation.mbahbabat.workers.dev';
			
			let APIKEY = null;
			let ISEXECUTION = false; 
			
			function updateExecutionStatus(status) {
				ISEXECUTION = status;
			}
			
			// ========== SETUP LISTENER ==========
			function setupListener() {
				emailInput.addEventListener('input', function () {
					updateInputLineNumbers();
				});
			
				emailInput.addEventListener('scroll', inputLineNumbersScroll);
				pasteBtn.addEventListener('click', handlePaste);
				uploadBtn.addEventListener('click', () => fileInput.click());
				fileInput.addEventListener('change', handleFileUpload);
				clearInputBtn.addEventListener('click', clearInput);
				clearErrorsBtn.addEventListener('click', clearErrors);
				resetBtn.addEventListener('click', resetSystem);
				copyBtn.addEventListener('click', copyResults);
				downloadBtn.addEventListener('click', downloadResults);
				resultListContainer.addEventListener('scroll', handleScroll);
				stopExecutionBtn.addEventListener('click', cancelExecution);
								
				if (myAccountButton) {
					myAccountButton.addEventListener('click', showMyAccountModal);
				}
			
				emailInput.addEventListener('click', function () {
					validateInput();
					updateInputLineNumbers();
				});
			
				emailInput.addEventListener('blur', function () {
					validateInput();
					updateInputLineNumbers();
				});	
				
				window.addEventListener('resize', function () {
					validateInput();
					updateInputLineNumbers();
				});	
				
				executeBtn.addEventListener('click', async function () {
				
					if (!APIKEY){
						systemMessage.textContent = "PLEASE WAIT...";
					}
					 await validateInput();
				
					if (invalidEmails.length > 0) {
						return;
					}
				
					emailInput.value = validEmails.join('\n');
				
					const emails = emailInput.value.split('\n')
						.map(email => email.trim())
						.filter(email => email.length > 0);
				
					if (emails.length === 0) {
						return;
					}
				
					// Tampilkan overlay progress
					progressOverlay.classList.remove('hidden');
					systemMessage.textContent = "EXECUTING...";
					executeBtn.disabled = true;
					
					inputButtonContainer.classList.add('hidden');
					stopButttonContainer.classList.remove('hidden');
					inputSection.classList.add('hidden');
					outputSection.classList.remove('hidden');
					errorInfo.classList.add('hidden');
					
					// Reset progress bar
					updateProgressBar(0);
					
					await EXECUTE();
				});
						
				filterBtns.forEach(btn => {
					btn.addEventListener('click', () => {
						filterBtns.forEach(b => b.classList.remove('active'));
						btn.classList.add('active');
						currentFilter = btn.dataset.filter;
						copyBtn.innerHTML = `<p><i class="fas fa-copy"></i> COPY </p> <p style="padding-top: 5px;border-top:1px dashed orange;font-weight: normal;font-size: 0.6em"><i class="fa-regular fa-envelope-open"></i> status: ${currentFilter.toUpperCase()}</p>`;
						downloadBtn.innerHTML = `<p><i class="fas fa-download"></i> DOWNLOAD(TXT)</p><p style="padding-top: 5px; border-top:1px dashed orange;font-weight: normal;font-size: 0.6em"><i class="fa-solid fa-envelope"></i> status: ${currentFilter.toUpperCase()}</p>`;
						resultListContainer.scrollTop = 0; // Reset scroll position saat filter berubah
						displayResults(); // Panggil displayResults untuk merender ulang dengan filter baru
					});
				});
			}
			
			// ========== START APP  ==========
			async function START() {
				updateInputLineNumbers();
				await initDb();
				setupListener();
				validateInput();
				await initHistorySystem();	
			}
			
			// ========== AWAITING DOM ==========
			document.addEventListener('DOMContentLoaded', function () {
				const systemDelayStatus = initLoadingSystem();
				const systemDelay = systemDelayStatus.initDelay;			
				initLoadingSystem();
				setTimeout(function () {
					START();
				}, systemDelay);

			});	
										
		</script>
		<script type="module" id="INIT-DB">
			import {
				initializeApp
			} from "https://www.gstatic.com/firebasejs/11.3.0/firebase-app.js";
			import {
				getAuth,
				signInAnonymously,
				onAuthStateChanged,
				GoogleAuthProvider,
				getRedirectResult,
				signInWithPopup,
				signInWithRedirect,
				signOut
			} from "https://www.gstatic.com/firebasejs/11.3.0/firebase-auth.js";
			import {
				captchaSolver
			} from './captcha.js';
			import {
				syncUser
			} from './syncUser.js';
			
			let firebaseApp, auth;
			let currentChallenge = null;
			let currentUser = null;
			let isInitializing = false;
			let idToken = null;
			let firebaseInitPromise = null; // Promise yang akan diselesaikan ketika Firebase siap
			
			// ========== SELECTOR ==========
			
			async function initFirebase(captchaValue = null) {
				if (!firebaseInitPromise) {
					firebaseInitPromise = new Promise(async (resolve, reject) => {
						if (isInitializing) {
							console.alert('Firebase initialization already in progress (within new Promise creation).');
							return;
						}
			
						try {
							isInitializing = true;
			
							const cachedConfigStr = localStorage.getItem('config');
							if (cachedConfigStr) {
								try {
									const config = JSON.parse(cachedConfigStr);
									if (!firebaseApp) {
										firebaseApp = initializeApp(config);
										auth = getAuth(firebaseApp);
									}
									setupAuthListener(resolve);
									return;
								} catch (e) {
									console.warn("Cached Firebase config is invalid, fetching fresh", e);
									localStorage.removeItem('config');
								}
							}
			
							if (captchaValue) {
								await fetchFirebaseConfig(captchaValue);
								setupAuthListener(resolve);
								return;
							}
			
							await fetchFirebaseConfig();
							setupAuthListener(resolve);
			
						} catch (error) {
							console.error('Firebase init error:', error);
							currentChallenge = null;
							alert(`ðŸ”¥ Initialization failed: ${error.message}`);
							reject(error);
						} finally {
							isInitializing = false;
						}
					});
				}
				return firebaseInitPromise;
			}
			
			async function fetchFirebaseConfig(captchaValue = null) {
				let requestBody = {};
			
				if (!currentChallenge) {
					const getRes = await fetch(`${DB_URL}/firebase-config`, {
						method: 'GET'
					});
					if (!getRes.ok) throw new Error(`Challenge request failed: ${getRes.status}`);
					currentChallenge = await getRes.json();
				}
			
				const dataToSign = `${currentChallenge.nonce}:${currentChallenge.salt}`;
				const signature = await generateHMACClient(dataToSign, currentChallenge.tempToken);
			
				requestBody = {
					token: currentChallenge.tempToken,
					nonce: currentChallenge.nonce,
					signature
				};
			
				if (captchaValue) {
					requestBody.captchaValue = captchaValue;
				}
			
				const response = await fetch(`${DB_URL}/firebase-config`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify(requestBody)
				});
			
				if (response.ok) {
					const config = await response.json();
					localStorage.setItem('config', JSON.stringify(config));
					if (!firebaseApp) {
						firebaseApp = initializeApp(config);
						auth = getAuth(firebaseApp);
					}
					await signAnonym();
					return;
				}
			
				const errorBody = await response.json();
				switch (response.status) {
					case 428:
					case 403:
						if (errorBody.captchaRequired || response.status === 428) {
							const userSolution = await captchaSolver.solve(
								errorBody.captchaData,
								response.status === 403
							);
							currentChallenge = null;
							await fetchFirebaseConfig(userSolution);
						} else {
							throw new Error(errorBody.error || 'Akses ditolak (403)');
						}
						break;
					case 429:
						alert(`ðŸ”¥ ${errorBody.error}`);
						throw new Error('Rate limited');
					default:
						currentChallenge = null;
						throw new Error(errorBody.error || `Config request failed with status: ${response.status}`);
				}
			}
			
			function resetFirebaseInit() {
				currentChallenge = null;
				isInitializing = false;
				firebaseInitPromise = null; // Reset promise juga
			}
			
			function setupAuthListener(resolveInitPromise) {
				onAuthStateChanged(auth, async (user) => {
					currentUser = user;
			
					if (currentUser) {
						await syncUser(DB_URL, currentUser, {
							forceFullUpdate: true
						});
						idToken = await currentUser.getIdToken(true);
						if (resolveInitPromise) {
							resolveInitPromise(); // Selesaikan promise
							resolveInitPromise = null; // Pastikan hanya dipanggil sekali
						}
					} else {
						// Jika user logout atau belum login, sign anonym lagi
						await signAnonym();
					}
				});
			}
			
			async function initDb() {
				try {
					await initFirebase(); // Pastikan initFirebase dipanggil untuk membuat promise
				} catch (e) {
					console.error("Failed to initialize Firebase:", e);
				}
			}
			
			async function signAnonym() {
				let attempts = 0;
				const MAX_ATTEMPTS = 3;
				const RETRY_DELAY_MS = 1000;
			
				while (attempts < MAX_ATTEMPTS) {
					try {
						await signInAnonymously(auth);
						return; // Berhasil, keluar dari loop
					} catch (error) {
						console.error(`Attempt ${attempts + 1} to sign in anonymously failed:`, error);
						attempts++;
						if (attempts < MAX_ATTEMPTS) {
							await new Promise(res => setTimeout(res, RETRY_DELAY_MS));
						} else {
							console.error("Failed to sign in anonymously after multiple attempts.");
							throw error; // Lempar error jika semua percobaan gagal
						}
					}
				}
			}
			
			
			// API KEY MANAGEMENT
			const API_STORAGE_KEY = 'gmailChecker_apiData';
			const API_CACHE_DURATION = 12 * 30 * 24 * 60 * 60 * 1000;
			
			async function handleGenerateKey() {
				// Tunggu sampai inisialisasi Firebase selesai dan idToken tersedia
				if (!firebaseInitPromise) {
					console.warn("initFirebase was not called before handleGenerateKey. Initializing Firebase now...");
					await initFirebase(); // Panggil initFirebase jika belum
				} else {
					await firebaseInitPromise; // Tunggu jika sudah dipanggil
				}
			
				// Pastikan currentUser dan idToken sudah ada setelah inisialisasi selesai
				if (!currentUser || !idToken) {
					// Jika masih belum ada, coba sign in anonym lagi atau lempar error
					console.warn("currentUser or idToken not available after Firebase initialization. Attempting anonymous sign-in.");
					try {
						await signAnonym(); // Coba sign in anonym lagi
					} catch (e) {
						throw new Error("Failed to get authenticated user or ID token after Firebase initialization.");
					}
				}
			
			
				// Cek cache dulu
				const cached = getCachedApiData();
				if (cached && cached.apiKey) {
					APIKEY = cached.apiKey;
					return {
						APIKEY: cached.apiKey
					};
				}
			
				// Generate baru jika tidak ada cache
				try {
					const res = await fetch(`${SERVER_URL}/generate-free-key`, {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'Authorization': `Bearer ${idToken}` // idToken sudah pasti tersedia di sini
						}
					});
			
					if (!res.ok) throw new Error(`HTTP ${res.status}`);
			
					const data = await res.json();
					APIKEY = data.apiKey;
			
					// Simpan ke cache
					cacheApiData({
						apiKey: APIKEY,
						type: 'free',
						timestamp: Date.now()
					});
			
					return {
						APIKEY
					};
				} catch (err) {
					console.error('Generate API Key error:', err);
					throw err;
				}
			}
			
			function getCachedApiData() {
				try {
					const cached = localStorage.getItem(API_STORAGE_KEY);
					if (!cached) return null;
			
					const data = JSON.parse(cached);
					const isExpired = Date.now() - data.timestamp > API_CACHE_DURATION;
			
					return isExpired ? null : data;
				} catch (e) {
					return null;
				}
			}
			
			function cacheApiData(data) {
				localStorage.setItem(API_STORAGE_KEY, JSON.stringify({
					...data,
					timestamp: Date.now()
				}));
			}
			
			async function generateHMACClient(data, key) {
				try {
					const encoder = new TextEncoder();
					const cryptoKey = await crypto.subtle.importKey(
						"raw",
						encoder.encode(key), {
							name: "HMAC",
							hash: "SHA-256"
						},
						false,
						["sign"]
					);
			
					const signature = await crypto.subtle.sign(
						"HMAC",
						cryptoKey,
						encoder.encode(data)
					);
			
					return btoa(String.fromCharCode(...new Uint8Array(signature)))
						.replace(/\+/g, '-')
						.replace(/\//g, '_')
						.replace(/=+$/, '');
				} catch (error) {
					console.error('HMAC generation error:', error);
					throw new Error('Failed to generate HMAC signature');
				}
			}
			
			window.handleGenerateKey = handleGenerateKey;
			window.initDb = initDb;
			
									
		</script>
		<!-- INPUT -->
		<script id="INPUT-HANDLER">
			// ========== EMAILS - ARRAY ==========
			let invalidEmails = [];
			let validEmails = [];
			
			// ========== INPUT LINE NUMBERS ==========
			function inputLineNumbersScroll() {
				lineNumbers.scrollTop = emailInput.scrollTop;
			}
			
			function updateInputLineNumbers() {
				const lines = emailInput.value.split('\n');
				lineNumbers.innerHTML = '';
				for (let i = 1; i <= lines.length; i++) {
					const line = document.createElement('div');
					line.textContent = i;
					lineNumbers.appendChild(line);
				}
			}
			
			// ========== PASTE BUTTON ==========
			function handlePaste() {
				navigator.clipboard.readText().then(text => {
					emailInput.value = text;
					updateInputLineNumbers();
				}).catch(err => {
					console.error('Failed to read clipboard contents: ', err);
					alert('Failed to paste from clipboard. Please paste manually.');
				});
			}
			
			// ========== UPLOAD BUTTON ==========
			function handleFileUpload(event) {
				const file = event.target.files[0];
				if (!file) return;
			
				const reader = new FileReader();
				reader.onload = function (e) {
					emailInput.value = e.target.result;
					updateInputLineNumbers();
					fileInput.value = ''; // Reset file input
				};
				reader.readAsText(file);
			}
			
			// ========== CLEAR INPUT BUTTON ==========
			function clearInput() {
				emailInput.value = '';
				validateInput();
				updateInputLineNumbers();
			}
			
			
			
			// ========== SANITIZE INPUT ==========
			function validateInput() {
				let rawEmails = emailInput.value.split('\n');
				let seenEmails = new Set();
				invalidEmails = [];
				validEmails = [];
			
				rawEmails.forEach((line, lineIndex) => {
					const lineNumber = lineIndex + 1;
					const potentialEmailPattern = /([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)/gi;
					let lastIndex = 0;
					let match;
			
					while ((match = potentialEmailPattern.exec(line)) !== null) {
						const textBefore = line.substring(lastIndex, match.index).trim();
						if (textBefore.length > 0) {
							// Simpan objek error, bukan string HTML langsung
							invalidEmails.push({
								lineNumber: lineNumber,
								text: textBefore,
								message: 'Not a valid email format',
								color: '#ff0055'
							});
						}
			
						let email = match[0].trim();
						lastIndex = potentialEmailPattern.lastIndex;
			
						if (email.length === 0) continue;
			
						const emailRegex = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+)@([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)$/;
						const gmailDomainRegex = /@gmail\.com$/i;
			
						if (!emailRegex.test(email)) {
							invalidEmails.push({
								lineNumber: lineNumber,
								text: email,
								message: 'Invalid email format',
								color: 'red' 
							});
							continue;
						}
			
						const localPart = email.split('@')[0];
						if (/[^a-zA-Z0-9._-]/.test(localPart)) {
							invalidEmails.push({
								lineNumber: lineNumber,
								text: email,
								message: 'Contains invalid characters in local part',
								color: 'orange'
							});
							continue;
						}
			
						if (!gmailDomainRegex.test(email)) {
							const domain = email.split('@')[1];
							invalidEmails.push({
								lineNumber: lineNumber,
								text: email,
								message: `Wrong domain: ${domain}`,
								color: 'blue'
							});
							continue;
						}
			
						if (seenEmails.has(email.toLowerCase())) {
							invalidEmails.push({
								lineNumber: lineNumber,
								text: email,
								message: 'Duplicate email',
								color: 'purple'
							});
							continue;
						}
			
						validEmails.push(email);
						seenEmails.add(email.toLowerCase());
					}
			
					const remainingText = line.substring(lastIndex).trim();
					if (remainingText.length > 0) {
						invalidEmails.push({
							lineNumber: lineNumber,
							text: remainingText,
							message: 'Not a valid email format',
							color: '#ff0055'
						});
					}
				});
			
				displayErrors();
			}
			
			// ========== ERRORS TOGGLE  ==========
			function toggleErrorBtn() {
				if (invalidEmails.length > 0) {
					executeBtn.disabled = true;
					pasteBtn.disabled = true;
					uploadBtn.disabled = true;
					clearInputBtn.classList.add('hidden');
					clearErrorsBtn.classList.remove('hidden');
				} else {
					executeBtn.disabled = false;
					pasteBtn.disabled = false;
					uploadBtn.disabled = false;
					clearInputBtn.classList.remove('hidden');
					clearErrorsBtn.classList.add('hidden');
				}
			}
			
			// ========== DISPLAY INVALID EMAILS  ==========
			let messageInterval = null;
			
			function displayErrors() {
				if (messageInterval) {
					clearInterval(messageInterval);
					messageInterval = null;
				}
			
				toggleErrorBtn();
				errorList.innerHTML = ''; // Bersihkan dulu
			
				if (invalidEmails.length > 0) {
					errorInfo.classList.remove('hidden');
					systemMessage.textContent = `${invalidEmails.length} invalid emails detected`;
					invalidEmails.forEach(err => {
						const p = document.createElement('p');
			
						// Bagian teks utama
						const textNode = document.createTextNode(`Line ${err.lineNumber}: ${err.text} - `);
						p.appendChild(textNode);
			
						// Bagian pesan kesalahan dengan warna
						const span = document.createElement('span');
						span.style.color = err.color;
						span.textContent = err.message; 
						p.appendChild(span);
			
						errorList.appendChild(p);
					});
				} else {
					errorList.innerHTML = '';
					errorInfo.classList.add('hidden');
			
					const noInput = emailInput.value.trim().length === 0;
			
					if (noInput) {
						systemMessage.textContent = 'ENTER AT LEAST 1 VALID EMAIL ADDRESS';
						return;
					}
			
					systemMessage.textContent = getRandomMessage();
			
					messageInterval = setInterval(() => {
						if (ISEXECUTION) {
							return; // don't update any messages!
						}
						systemMessage.textContent = getRandomMessage();
					}, 15000);
				}
			
				
				function getRandomMessage() {
					const messages = [
						"CLICK EXECUTE BUTTON TO START",
						"ONLY ACCEPTS THE GMAIL.COM DOMAIN",
						"INSTANT VERIFICATION IN SECONDS",
						"PASTE MULTIPLE EMAILS FOR QUICK CHECK",
						"ENSURE ALL EMAILS ARE GMAIL ACCOUNTS",
						"ONLY GMAIL ADDRESSES ARE SUPPORTED",
						"AUTO REMOVE INVALID OR MALFORMED EMAILS",
						"SKIP NON-GMAIL ADDRESSES AUTOMATICALLY",
						"GET REAL-TIME VALIDATION FEEDBACK",
						"SAVE YOUR TIME â€” CHECK 1000 EMAILS IN SECONDS",
						"BULK PROCESSING AT LIGHTNING SPEED",
						"INSTANT RESULTS, ZERO WAITING",
						"NO MORE MANUAL CHECKING!",
						"AUTOMATE YOUR EMAIL VALIDATION",
						"CATCH INVALID, FAKE, OR TYPOED EMAILS",
						"REAL-TIME VERIFICATION ENGINE",
						"ONLY VALID GMAILS PASS THROUGH",
						"JUST PASTE & CLICK â€” ITâ€™S THAT EASY",
						"PASTE YOUR GMAILS AND CLICK EXECUTE",
						"SUPPORTS MULTIPLE EMAILS â€” ONE PER LINE",
						"ONLY GMAIL.COM ADDRESSES ACCEPTED"
					];
			
					const randomIndex = Math.floor(Math.random() * messages.length);
					return messages[randomIndex];
				}
			}
			
			// ========== CLEAR INVALID EMAILS  ==========
			async function clearErrors() {
				emailInput.value = validEmails.join('\n');
				invalidEmails = [];
				errorList.innerHTML = '';
				toggleErrorBtn();
				validateInput();	
				updateInputLineNumbers();				
			}
			
		</script>
		<!-- API KEY -->
		<script id="API-KEY-STATS">
			const API_STATS_CACHE_KEY = 'gmailChecker_apiStats';
			const API_STATS_CACHE_DURATION = 60 * 60 * 1000; // 1 jam
			
			// Helper functions (tetap sama)
			function getCachedApiStats() {
				try {
					const cached = localStorage.getItem(API_STATS_CACHE_KEY);
					return cached ? JSON.parse(cached) : null;
				} catch (e) {
					console.error("Error parsing cached API stats:", e);
					return null;
				}
			}
			
			function setCachedApiStats(data) {
				localStorage.setItem(API_STATS_CACHE_KEY, JSON.stringify(data));
			}
			
			function isCacheExpired(cachedData) {
				if (!cachedData || !cachedData.cachedAt) return true;
				return Date.now() - cachedData.cachedAt > API_STATS_CACHE_DURATION;
			}
			
			function calculateResetTimestamp() {
				// Default: reset setiap 24 jam dari sekarang
				return Date.now() + (24 * 60 * 60 * 1000);
			}
			
			function generateApiStatsHtml(data) {
				if (!data || data.error) {
					return `<p class="status-error">${data?.error || 'Failed to load API statistics.'}</p>`;
				}
			
				// Pastikan data yang diperlukan ada, berikan fallback jika tidak
				const type = data.type || 'N/A';
				const requestsUsed = data.requestsUsed || 0;
				const maxRequests = data.maxRequests || 0;
				const remainingRequests = data.remainingRequests || 0;
				const resetPeriod = data.resetPeriod || 'N/A';
				const nextResetUTC = data.nextResetUTC || 'Tomorrow';
				const owner = data.owner || 'N/A';
			
				return `
					<div class="stats-grid">
						<div class="stat-item">
							<p>Key Type</p>
							<strong>${type}</strong>
						</div>
						<div class="stat-item">
							<p>Requests Used</p>
							<strong>${requestsUsed}</strong>
						</div>
						<div class="stat-item">
							<p>Daily Requests</p>
							<strong>${maxRequests}</strong>
						</div>
						<div class="stat-item">
							<p>Remaining Requests</p>
							<strong>${remainingRequests}</strong>
						</div>
						<div class="stat-item">
							<p>Reset Period</p>
							<strong>${resetPeriod}</strong>
						</div>
						<div class="stat-item">
							<p>Reset Countdown</p>
							<strong id="countdown">Calculating...</strong>
						</div>
						<div class="stat-item">
							<p>Next Reset (UTC)</p>
							<strong>${nextResetUTC}</strong>
						</div>
						<div class="stat-item">
							<p>Owner</p>
							<strong>${owner}</strong>
						</div>                                          
					</div>
				`;
			}
			
			function renderApiStats(data) {
				let apiStatsContainer = document.getElementById('api-stats-container');
			
				if (!apiStats) {
					console.error("Parent element 'apiStats' not found for API stats container.");
					return;
				}
			
				if (!apiStatsContainer) {
					apiStatsContainer = document.createElement('div');
					apiStatsContainer.id = 'api-stats-container';
					apiStats.appendChild(apiStatsContainer);
				}
				
				// Tampilkan/sembunyikan parent sesuai data
				if (data && !data.error) {
					apiStats.classList.remove('hidden');
				} else {
					// Jika tidak ada data atau ada error, mungkin Anda ingin tetap menampilkan container
					// atau menyembunyikannya, sesuaikan ini. Untuk demo, tetap ditampilkan dengan error.
					apiStats.classList.remove('hidden'); 
				}
			
				apiStatsContainer.innerHTML = generateApiStatsHtml(data);
			
				// Mulai countdown jika data valid dan memiliki timestamp reset
				if (data && data.resetTimestamp && !data.error) {
					startCountdown(data.resetTimestamp);
				} else {
					// Hentikan/bersihkan countdown jika ada error atau tidak ada timestamp
					const countdownEl = document.getElementById('countdown');
					if (countdownEl) countdownEl.textContent = 'N/A';
				}
			
				// Set pesan sistem
				if (systemMessage) { // Asumsi systemMessage adalah elemen UI untuk pesan
					setTimeout(() => {
						systemMessage.textContent = data && !data.error ? `API KEY STATISTICS` : `API STATS ERROR`;
					}, 3000);
				}
			}
			
			async function getApiStatsData() {
				let cached = getCachedApiStats();
			
				// 1. Cek cache
				if (cached && !isCacheExpired(cached)) {
					return cached;
				}
			
				// 2. Jika tidak ada cache atau expired, fetch dari server
				if (!APIKEY) { // Asumsi APIKEY sudah didefinisikan secara global atau di scope yang tepat
					try {
						const getApiKey = await handleGenerateKey(); // Asumsi handleGenerateKey ada
						APIKEY = getApiKey.APIKEY;
					} catch (keyError) {
						console.error("Error generating API key:", keyError);
						return { error: `Failed to get API key: ${keyError.message}` };
					}
				}
			
				try {
					const response = await fetch(`${SERVER_URL}/stats?key=${APIKEY}`); // Asumsi SERVER_URL ada
			
					if (!response.ok) {
						const errorData = await response.json();
						throw new Error(errorData.error || `Failed to fetch stats (status ${response.status})`);
					}
			
					const data = await response.json();
					
					const statsData = {
						...data,
						cachedAt: Date.now(),
						resetTimestamp: data.resetTimestamp || calculateResetTimestamp()
					};
					
					setCachedApiStats(statsData);
					return statsData;
					
				} catch (error) {
					console.error("Error fetching API stats:", error);
					
					// Fallback ke cache jika ada, meskipun expired
					if (cached) {
						console.warn("Using expired cache due to fetch error.");
						return cached; // Kembalikan cache expired
					}
					
					// Jika tidak ada cache sama sekali, kembalikan objek error
					return { error: error.message };
				}
			}
			
			async function initializeApiStats() {
				const stats = await getApiStatsData();
				renderApiStats(stats);
				return stats; // Kembalikan stats untuk penggunaan lebih lanjut jika diperlukan
			}
			
			async function updateApiStatsAfterExecution(emailsProcessed) {
				let cached = await getCachedApiStats();
				if (!cached) {
					// Jika tidak ada cache, coba fetch data baru
					console.warn("No cached stats to update after execution. Fetching new data.");
					const newStats = await getApiStatsData();
					renderApiStats(newStats);
					return;
				}
			
				// Update requests used dan remaining
				cached.requestsUsed = (cached.requestsUsed || 0) + emailsProcessed;
				cached.remainingRequests = Math.max(0, (cached.remainingRequests || 0) - emailsProcessed);
				cached.lastUpdated = Date.now(); // Tambahkan field lastUpdated jika relevan
			
				setCachedApiStats(cached);
				renderApiStats(cached); // Render ulang dengan data yang diupdate
			}
			
			function startCountdown(resetTimestamp) {
				const countdownEl = document.getElementById('countdown');
				if (!countdownEl) {
					console.warn("Countdown element not found.");
					return;
				}
			
				let intervalId = countdownEl.dataset.intervalId;
				if (intervalId) {
					clearInterval(parseInt(intervalId)); // Hentikan interval lama jika ada
				}
			
				const targetTime = resetTimestamp;
			
				function updateCountdown() {
					const now = Date.now();
					const diff = targetTime - now;
			
					if (diff <= 0) {
						countdownEl.textContent = "RESET!";
						clearInterval(currentIntervalId); // Hentikan interval
						localStorage.removeItem(API_STATS_CACHE_KEY); // Hapus cache untuk force refresh
						// Optionally, re-initialize stats here to get new data
						// initializeApiStats(); 
						return;
					}
			
					const hours = Math.floor(diff / (1000 * 60 * 60));
					const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
					const seconds = Math.floor((diff % (1000 * 60)) / 1000);
			
					countdownEl.textContent =
						`${hours.toString().padStart(2, '0')}:` +
						`${minutes.toString().padStart(2, '0')}:` +
						`${seconds.toString().padStart(2, '0')}`;
				}
			
				updateCountdown(); // Panggil pertama kali segera
				const currentIntervalId = setInterval(updateCountdown, 1000);
				countdownEl.dataset.intervalId = currentIntervalId.toString(); // Simpan ID interval
			}
			
			async function forceRefreshStats() {
				localStorage.removeItem(API_STATS_CACHE_KEY);
				return await initializeApiStats(); // Memanggil ulang inisialisasi untuk refresh
			}
			
		</script>
		<!-- EXECUTOR -->
		<script id="EXECUTOR">
			// ========== API SERVER  ==========
			const server1 = `${SERVER_URL}/check1`;
			const server2 = `${SERVER_URL}/check2`;
			const fastServer = `${SERVER_URL}/fastcheck`;
			
			
			let abortController = null;
			let selectedMode = 'normal';
			let chunks = [];
			let currentProgress = 0; 
			
			async function EXECUTE() {
				updateExecutionStatus(true);
				
				emailInput.value = validEmails.join('\n'); 
			
				const emails = emailInput.value.split('\n')
					.map(email => email.trim())
					.filter(email => email.length > 0);
			
				let chunkSize;
				let server;
			
				if (selectedMode === 'normal') {
					chunkSize = 100;
					server = server2;
				} else if (selectedMode === 'fast') {
					chunkSize = 10000;
					server = fastServer;
				}
			
				chunks = [];
				for (let i = 0; i < emails.length; i += chunkSize) {
					chunks.push(emails.slice(i, i + chunkSize));
				}
			
				results = [];
				abortController = new AbortController(); 
				currentProgress = 0;
				updateProgressBar(0);
				systemMessage.textContent = "INITIALIZING..."; 
			
				try {
					if (selectedMode === 'normal') {
						await processChunksWithFallback(chunks, server);
					} else {
						await processChunks(chunks, server);
					}
			
					if (abortController.signal.aborted) {
						throw new Error('Aborted by user.'); 
					}
			
					await animateProgressBar(currentProgress, 100);
					progressOverlay.classList.add('hidden');
					stopButttonContainer.classList.add('hidden');
					outputButtonContainer.classList.remove('hidden');
					apiStats.classList.remove('hidden');
					systemMessage.textContent = "EXECUTION COMPLETED!";
			
					await saveCurrentResults(); 
					await updateApiStatsAfterExecution(results.length);
			
					updateCounters(); 
					resultListContainer.scrollTop = 0;
					displayResults(); 
			
				} catch (error) {
					if (error.name === 'EXECUTION CANCELLED' || error.message === 'Aborted by user.') {
						systemMessage.textContent = "EXECUTION CANCELLED";
					} else {
						console.error('Execution error:', error);
						systemMessage.textContent = `${error.message}`;
					}
					progressOverlay.classList.add('hidden');
				} 
			}
			
			
			async function processChunksWithFallback(chunks, primaryServer) {
				if (abortController.signal.aborted) return; // Cek awal
			
				if (!APIKEY) {
					try {
						const getApiKey = await handleGenerateKey();
						APIKEY = getApiKey.APIKEY;
					} catch (error) {
						if (error.name === 'EXECUTION CANCELLED') throw error; // Re-throw AbortError
						console.error("Failed to get API Key:", error);
						throw new Error("Failed to initialize API key for execution.");
					}
				}
			
				let currentServer = primaryServer;
				let usedFallback = false;
			
				for (let i = 0; i < chunks.length; i++) {
					if (abortController.signal.aborted) {
						throw new Error('EXECUTION CANCELLED'); // Lempar AbortError untuk keluar dari loop dan masuk ke catch di EXECUTE
					}
			
					const chunk = chunks[i];
					const targetProgress = (((i + 1) / chunks.length) * 100);
			
					try {
						const response = await fetchWithTimeout(currentServer, {
							method: 'POST',
							headers: {
								'Authorization': `Bearer ${APIKEY}`,
								'Content-Type': 'application/json'
							},
							body: JSON.stringify({
								mail: chunk
							})
						}, 60000, abortController.signal); 
			
						if (abortController.signal.aborted) {
							throw new Error('EXECUTION CANCELLED');
						}
			
						const data = await response.json();
						processApiResponse(data);
			
						if (abortController.signal.aborted) { // Cek setelah proses API
							throw new Error('EXECUTION CANCELLED');
						}
			
						updateCounters();
						displayResults();
			
						await animateProgressBar(currentProgress, targetProgress);
						if (abortController.signal.aborted) { // Cek setelah animasi
							throw new Error('EXECUTION CANCELLED');
						}
						systemMessage.textContent = `PROCESSING... ${currentProgress.toFixed(0)}%`;
			
			
					} catch (error) {
						if (error.name === 'EXECUTION CANCELLED') {
							throw error; // Re-throw AbortError
						}
						console.error(`Error with ${currentServer}:`, error);
			
						if (!usedFallback && currentServer === server2) {
							currentServer = server1;
							usedFallback = true;
							i--;
							continue;
						}
			
						throw error;
					}
			
					if (i < chunks.length - 1) {
						await new Promise(resolve => setTimeout(resolve, 10));
						if (abortController.signal.aborted) { 
							throw new Error('EXECUTION CANCELLED');
						}
					}
				}
			}
			
			
			async function processChunks(chunks, server) {
				if (abortController.signal.aborted) return; 
			
				if (!APIKEY) {
					try {
						const getApiKey = await handleGenerateKey();
						APIKEY = getApiKey.APIKEY;
					} catch (error) {
						if (error.name === 'EXECUTION CANCELLED') throw error;
						console.error("Failed to get API Key:", error);
						throw new Error("Failed to initialize API key for execution.");
					}
				}
			
				for (let i = 0; i < chunks.length; i++) {
					if (abortController.signal.aborted) {
						throw new Error('EXECUTION CANCELLED');
					}
			
					const chunk = chunks[i];
					const targetProgress = (((i + 1) / chunks.length) * 100);
			
					try {
						const response = await fetch(server, {
							method: 'POST',
							headers: {
								'Authorization': `Bearer ${APIKEY}`,
								'Content-Type': 'application/json'
							},
							body: JSON.stringify({
								mail: chunk
							}),
							signal: abortController.signal 
						});
			
						// Cek abort lagi setelah fetch selesai
						if (abortController.signal.aborted) {
							throw new Error('EXECUTION CANCELLED');
						}
			
						const data = await response.json();
						processApiResponse(data);
			
						if (abortController.signal.aborted) { 
							throw new Error('EXECUTION CANCELLED');
						}
			
						updateCounters();
						displayResults();
			
						await animateProgressBar(currentProgress, targetProgress);
						if (abortController.signal.aborted) { 
							throw new Error('EXECUTION CANCELLED');
						}
						systemMessage.textContent = `PROCESSING... ${currentProgress.toFixed(0)}%`;
			
					} catch (error) {
						if (error.name === 'EXECUTION CANCELLED') {
							throw error; 
						}
						console.error(`Error in processChunks with ${server}:`, error);
						throw error;
					}
			
			
					if (i < chunks.length - 1) {
						await new Promise(resolve => setTimeout(resolve, 10));
						if (abortController.signal.aborted) { // Cek setelah delay
							throw new Error('EXECUTION CANCELLED');
						}
					}
				}
			}
			
			// Fungsi helper untuk fetch dengan timeout
			function fetchWithTimeout(url, options, timeout, outerSignal) {
				return new Promise((resolve, reject) => {
					const controller = new AbortController();
					const timeoutId = setTimeout(() => {
						controller.abort();
						reject(new Error('Request timeout'));
					}, timeout);
			
					// Tambahkan listener untuk sinyal abort eksternal
					if (outerSignal) {
						outerSignal.addEventListener('abort', () => {
							clearTimeout(timeoutId); 
							controller.abort(); 
							reject(new Error('EXECUTION CANCELLED')); 
						}, {
							once: true
						});
					}
			
					options.signal = controller.signal; 
			
					fetch(url, options)
						.then(response => {
							clearTimeout(timeoutId);
							resolve(response);
						})
						.catch(error => {
							clearTimeout(timeoutId);
							reject(error);
						});
				});
			}
			
			function processApiResponse(data) {
			
				if (abortController && abortController.signal.aborted) {
					return; 
				}
			
				if (!Array.isArray(data)) {
					console.error('Invalid API response:', data);
					return;
				}
			
				data.forEach(item => {
					const normalizedStatus = item.status.toLowerCase();
					results.push({
						email: item.email,
						status: normalizedStatus,
						details: item.details || ''
					});
				});
			}
			
			
			// Fungsi untuk membatalkan eksekusi
			function cancelExecution() {
				if (abortController) {
					abortController.abort();
					systemMessage.textContent = "EXECUTION CANCELLED";
					executeBtn.disabled = false;
			
			
					stopButttonContainer.classList.add('hidden');
			
			
					inputSection.classList.remove('hidden');
					inputButtonContainer.classList.remove('hidden');
					outputSection.classList.add('hidden');
					outputButtonContainer.classList.add('hidden');
					progressOverlay.classList.add('hidden');
					apiStats.classList.add('hidden');
					errorInfo.classList.remove('hidden');
					clearInput();
					results = [];
					currentFilter = 'all';
					filterBtns.forEach(btn => {
						btn.classList.remove('active');
						if (btn.dataset.filter === 'all') {
							btn.classList.add('active');
						}
					});
					updateCounters();
					resultList.innerHTML = '';
					resultList.style.height = 'auto';
					resultListContainer.scrollTop = 0;
			
					// Set initial system message
					updateProgressBar(0);
					validateInput();
					updateInputLineNumbers();
					updateExecutionStatus(false);
				}
			}
			
			// Fungsi untuk mengupdate tampilan progress bar
			function updateProgressBar(percentage) {
				const clampedPercentage = Math.min(100, Math.max(0, percentage)); // Pastikan antara 0-100
				donutChart.style.background = `conic-gradient(#cc0000 ${clampedPercentage}%, #333 ${clampedPercentage}% 100%)`;
				progressText.textContent = `${clampedPercentage.toFixed(0)}%`;
			}
			
			// Fungsi baru untuk menganimasikan progress bar
			async function animateProgressBar(start, end) {
				const duration = Math.abs(end - start) * 10; // 10ms per 1% untuk total 100% = 1 detik. Bisa diatur.
				const startTime = performance.now();
			
				return new Promise(resolve => {
					function step(currentTime) {
						const elapsedTime = currentTime - startTime;
						const progressRatio = Math.min(1, elapsedTime / duration);
						const animatedValue = start + (end - start) * progressRatio;
			
						updateProgressBar(animatedValue);
						currentProgress = animatedValue; // Update global progress
			
						if (progressRatio < 1 && !abortController.signal.aborted) {
							requestAnimationFrame(step);
						} else {
							updateProgressBar(end); // Pastikan berakhir di nilai target
							currentProgress = end;
							resolve();
						}
					}
					requestAnimationFrame(step);
				});
			}
			
			// ========== RESET SYSTEM  ==========
			function resetSystem() {
				createLoadingAnimation(duration = 'fast')
			
				executeBtn.disabled = false;
				inputSection.classList.remove('hidden');
				inputButtonContainer.classList.remove('hidden');
				outputSection.classList.add('hidden');
				outputButtonContainer.classList.add('hidden');
				progressOverlay.classList.add('hidden');
				apiStats.classList.add('hidden');
				errorInfo.classList.remove('hidden');
				clearInput();
				results = [];
				currentFilter = 'all';
				filterBtns.forEach(btn => {
					btn.classList.remove('active');
					if (btn.dataset.filter === 'all') {
						btn.classList.add('active');
					}
				});
				updateCounters();
				resultList.innerHTML = '';
				resultList.style.height = 'auto';
				resultListContainer.scrollTop = 0;
			
				// Set initial system message
				updateProgressBar(0);
				validateInput();
				updateInputLineNumbers();
				updateExecutionStatus(false);
			}
		</script>
		<!-- RESULTS -->
		<script id="RESULT-HANDLER">
			// ========== RESULTS - ARRAY  ==========
			let results = [];
			
			// ========== CURRENT FILTER - RESULTS ==========
			let currentFilter = 'all';
			
			// ========== VIRTUAL SCROLL  ==========
			const ITEM_HEIGHT = 35;
			const OVERSCAN = 10;
			let startIndex = 0;
			let endIndex = 0;
			let resultVirtualScrollTimer;
			
			// ========== DISPLAY RESULTS  ==========
			// --- debounce function ---
			function debounce(func, delay) {
				let timeout;
				return function (...args) {
					const context = this;
					clearTimeout(timeout);
					timeout = setTimeout(() => func.apply(context, args), delay);
				};
			}
			
			// --- calculateVisibleItems function ---
			function calculateVisibleItems() {
				const scrollTop = resultListContainer.scrollTop;
				const containerHeight = resultListContainer.clientHeight;
				const filteredResults = currentFilter === 'all' ?
					results :
					results.filter(item => item.status === currentFilter);
				const totalItems = filteredResults.length;
			
				// Hitung startIndex dan endIndex berdasarkan posisi scroll
				startIndex = Math.max(0, Math.floor(scrollTop / ITEM_HEIGHT) - OVERSCAN);
				endIndex = Math.min(totalItems - 1, Math.ceil((scrollTop + containerHeight) / ITEM_HEIGHT) + OVERSCAN);
			
				// Hitung tinggi padding atas dan bawah
				const paddingTop = startIndex * ITEM_HEIGHT;
				const paddingBottom = (totalItems - 1 - endIndex) * ITEM_HEIGHT;
			
				return {
					startIndex,
					endIndex,
					paddingTop,
					paddingBottom,
					totalItems,
					filteredResults
				};
			}
			
			// --- handleScroll---
			function handleScroll() {
				// Panggil displayResults yang sudah di-debounce
				if (resultVirtualScrollTimer) clearTimeout(resultVirtualScrollTimer);
				resultVirtualScrollTimer = setTimeout(displayResults, 50); // Debounce 50ms
			}
			
			// --- Core---
			function displayResults() {
				updateExecutionStatus(true);
				
				const {
					startIndex,
					endIndex,
					paddingTop,
					paddingBottom,
					totalItems,
					filteredResults
				} = calculateVisibleItems();
			
				resultList.innerHTML = ''; // Kosongkan daftar yang ada
			
				if (totalItems === 0) {
					resultList.innerHTML = '<p>No results found for this filter.</p>';
					return;
				}
			
				// Tambahkan padding atas untuk item yang tidak terlihat di atas
				const topPaddingDiv = document.createElement('div');
				topPaddingDiv.style.height = `${paddingTop}px`;
				resultList.appendChild(topPaddingDiv);
			
				// Render hanya item yang terlihat
				for (let i = startIndex; i <= endIndex; i++) {
					const item = filteredResults[i];
					if (!item) continue; // Safety check
			
					const div = document.createElement('div');
					div.className = 'result-item';
					// Gaya display, align-items, gap sudah di CSS
			
					const numberSpan = document.createElement('span');
					numberSpan.textContent = `${i + 1}`; // Nomor berdasarkan indeks keseluruhan, bukan indeks yang dirender
					numberSpan.style.cssText = "min-width: 25px; text-align: right; display: inline-block; pointer-events: none; user-select: none;";
					numberSpan.classList.add('number-prefix');
			
					const emailStatusSpan = document.createElement('span');
					let emailText = item.email;
			
					emailStatusSpan.classList.add(`status-${item.status}`);
			
					if (currentFilter === 'all') {
						emailText += ` - ${item.status.charAt(0).toUpperCase() + item.status.slice(1)}`;
					}
					emailStatusSpan.textContent = emailText;
					emailStatusSpan.style.flexGrow = '1';
			
					div.appendChild(numberSpan);
					div.appendChild(emailStatusSpan);
					resultList.appendChild(div);
				}
			
				// Atur tinggi total resultList agar scrollbar berfungsi dengan benar
				resultList.style.height = `${totalItems * ITEM_HEIGHT}px`;
			}
			
			// ========== UPDATE COUNTERS  ==========		
			function updateCounters() {
				updateExecutionStatus(true);
				
				const allCount = results.length;
				const liveCount = results.filter(item => item.status === 'live').length;
				const verCount = results.filter(item => item.status === 'verify').length;
				const disabledCount = results.filter(item => item.status === 'disabled').length;
				const unregisteredCount = results.filter(item => item.status === 'unregistered').length;
				const errorCount = results.filter(item => item.status === 'error').length;
			
				countAll.textContent = `(${allCount})`;
				countLive.textContent = `(${liveCount})`;
				countVer.textContent = `(${verCount})`;
				countDisabled.textContent = `(${disabledCount})`;
				countUnregistered.textContent = `(${unregisteredCount})`;
				countError.textContent = `(${errorCount})`;
			}			
			
			// ========== COPY RESULTS HANDLER  ==========
			function copyResults() {
				const filteredResults = currentFilter === 'all' ?
					results :
					results.filter(item => item.status === currentFilter);
			
				if (filteredResults.length === 0) {
					alert('No results to copy.');
					return;
				}
			
				let textToCopy;
				if (currentFilter === 'all') {
					// Salin email dan status jika filter 'all'
					textToCopy = filteredResults.map(item => `${item.email} - ${item.status.charAt(0).toUpperCase() + item.status.slice(1)}`).join('\n');
				} else {
					// Hanya salin email untuk filter lainnya
					textToCopy = filteredResults.map(item => item.email).join('\n');
				}
			
				navigator.clipboard.writeText(textToCopy)
					.then(() => {
						alert('Results copied to clipboard!');
					})
					.catch(err => {
						console.error('Failed to copy: ', err);
						alert('Failed to copy results to clipboard.');
					});
			}
			
			// ========== DOWNLOAD RESULTS HANDLER  ==========
			function downloadResults() {
				const filteredResults = currentFilter === 'all' ?
					results :
					results.filter(item => item.status === currentFilter);
			
				if (filteredResults.length === 0) {
					alert('No results to download.');
					return;
				}
			
				let textToDownload;
				if (currentFilter === 'all') {
					// Unduh email dan status jika filter 'all'
					textToDownload = filteredResults.map(item => `${item.email} - ${item.status.charAt(0).toUpperCase() + item.status.slice(1)}`).join('\n');
				} else {
					// Hanya unduh email untuk filter lainnya
					textToDownload = filteredResults.map(item => item.email).join('\n');
				}
			
			             // Format tanggal dan waktu lokal
			             const now = new Date();
			             const year = now.getFullYear();
			             const month = String(now.getMonth() + 1).padStart(2, '0');
			             const day = String(now.getDate()).padStart(2, '0');
			             const hours = String(now.getHours()).padStart(2, '0');
			             const minutes = String(now.getMinutes()).padStart(2, '0');
			             const seconds = String(now.getSeconds()).padStart(2, '0');
			             const dateTimeString = `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
			
			             // Hitung jumlah hasil untuk nama file
			             const resultCount = filteredResults.length;
			
				const blob = new Blob([textToDownload], {
					type: 'text/plain'
				});
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				// Nama file dengan jumlah, nama aplikasi (misal: BulkGmailChecker), tanggal dan waktu
				a.download = `${currentFilter.toUpperCase()}-${resultCount}-Gmails-BulkGmailChecker_${dateTimeString}.txt`;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
			}
			
		</script>
		<script>
			// ========== MY ACCOUNT MODAL ==========
			let myAccountModal = null;
			
			function createMyAccountModal() {
				return new Promise((resolve) => {
					// Hapus modal yang sudah ada jika ada
					if (myAccountModal) {
						myAccountModal.remove();
					}
					
					// Buat elemen modal
					myAccountModal = document.createElement('div');
					myAccountModal.id = 'my-account-modal';
					myAccountModal.className = 'modal';
					
					myAccountModal.innerHTML = `
						<div class="modal-content">
							<div class="modal-header">
								<h2>MY ACCOUNT</h2>
							</div>
							<div class="modal-body">
								<div class="api-key-section">
									<h3>YOUR API KEY</h3>
									<div class="api-key-display">
										<div class="api-key-value" id="api-key-value">Loading...</div>
										<button class="btn copy-api-key" id="copy-api-key-btn">
											<i class="fas fa-copy"></i> COPY
										</button>
									</div>
								</div>
								
								<div class="stats-section">
									<h3>API STATISTICS</h3>
									<div id="modal-stats-container">
										<p>Loading statistics...</p>
									</div>
								</div>
								
								<div class="history-section">
									<h3>HISTORY</h3>
									<div class="history-stats">
										<div class="history-stat" id="total-checks">Total: 0</div>
										<div class="history-stat" id="total-emails">Emails: 0</div>
									</div>
									<div class="history-list" id="history-list">
										<!-- History items will be loaded here -->
									</div>
									<button class="btn clear-history-btn" id="clear-all-history">
										<i class="fas fa-broom"></i> CLEAR ALL HISTORY
									</button>
								</div>
							</div>
							<div class="modal-footer">
								<button class="btn close-modal" id="close-my-account-modal">
									<i class="fas fa-times"></i> CLOSE
								</button>
							</div>
						</div>
					`;
					
					document.body.appendChild(myAccountModal);
					
					// Event listeners untuk modal
					document.getElementById('close-my-account-modal').addEventListener('click', closeMyAccountModal);
					document.getElementById('copy-api-key-btn').addEventListener('click', copyApiKey);
					document.getElementById('clear-all-history').addEventListener('click', clearAllHistoryUI);
					
					// Tutup modal saat klik di luar konten
					myAccountModal.addEventListener('click', function(event) {
						if (event.target === myAccountModal) {
							closeMyAccountModal();
						}
					});
					
					// Tutup modal dengan tombol ESC
					document.addEventListener('keydown', function(event) {
						if (event.key === 'Escape' && myAccountModal.style.display === 'flex') {
							closeMyAccountModal();
						}
					});
					
					// Resolve promise setelah modal selesai dibuat
					setTimeout(() => resolve(), 0);
				});
			}
			
			
			// Fungsi untuk debug - cek apakah elemen modal ada
			function checkModalElements() {
				const elements = [
					'history-list',
					'total-checks', 
					'total-emails',
					'modal-stats-container',
					'api-key-value'
				];
				
				elements.forEach(id => {
					const el = document.getElementById(id);
				});
			}
			
			// Panggil di showMyAccountModal untuk debug
			async function showMyAccountModal() {
				try {
					if (!myAccountModal) {
						await createMyAccountModal();
					}
					
					// Tampilkan modal
					myAccountModal.classList.remove('hidden');
					
					checkModalElements();
					
					// Load data
					await loadApiKeyData();
					await loadStatsDataModal();
					await loadHistory();
					
				} catch (error) {
					console.error('Error showing My Account modal:', error);
				}
			}
			
			function closeMyAccountModal() {
				if (myAccountModal) {
					myAccountModal.classList.add('hidden');
				}
			}
			
			async function loadApiKeyData() {
				if (!APIKEY){
					const getApiKey = await handleGenerateKey();
					APIKEY = getApiKey.APIKEY;			
				}		
				
				try {
					const apiKeyValue = document.getElementById('api-key-value');
					apiKeyValue.textContent = 'Retrieving API key...';
					
					// Tampilkan sebagian API key dengan masking
					if (APIKEY && APIKEY.length > 16) {
						const maskedKey = APIKEY.substring(0, 8) + 'â€¢'.repeat(16) + APIKEY.substring(APIKEY.length - 8);
						apiKeyValue.textContent = maskedKey;
						apiKeyValue.dataset.fullKey = APIKEY; // Simpan key lengkap untuk copy
					} else {
						apiKeyValue.textContent = 'Failed to load API key';
					}
				} catch (error) {
					console.error('Error loading API key:', error);
					document.getElementById('api-key-value').textContent = 'Error loading API key';
				}
			}
			
			async function loadStatsDataModal() {
				try {
					const statsContainer = document.getElementById('modal-stats-container');
					statsContainer.innerHTML = '<p>Loading statistics...</p>';
					
					const apiKeyStats = await getApiStatsData(); 
					const statsHtml = generateApiStatsHtml(apiKeyStats); 
			
					statsContainer.innerHTML = statsHtml; 
			
					if (apiKeyStats && apiKeyStats.resetTimestamp && !apiKeyStats.error) {
						startCountdown(apiKeyStats.resetTimestamp);
					}
					
				} catch (error) {
					console.error('Error loading stats:', error);
					document.getElementById('modal-stats-container').innerHTML = '<p class="status-error">Error loading statistics</p>';
				}
			}
			
			function copyApiKey() {
				const apiKeyValue = document.getElementById('api-key-value');
				const fullKey = apiKeyValue.dataset.fullKey;
				
				if (!fullKey) {
					alert('API key not available');
					return;
				}
				
				navigator.clipboard.writeText(fullKey)
					.then(() => {
						// Feedback visual
						const copyBtn = document.getElementById('copy-api-key-btn');
						const originalHtml = copyBtn.innerHTML;
						copyBtn.innerHTML = '<i class="fas fa-check"></i> COPIED!';
						copyBtn.style.backgroundColor = 'var(--secondary-orange)';
						
						setTimeout(() => {
							copyBtn.innerHTML = originalHtml;
							copyBtn.style.backgroundColor = '';
						}, 2000);
					})
					.catch(err => {
						console.error('Failed to copy API key: ', err);
						alert('Failed to copy API key to clipboard');
					});
			}
			
		</script>	
		<script>
			// ========== HISTORY SYSTEM WITH INDEXEDDB ==========
			const DB_NAME = 'GmailCheckerHistory';
			const DB_VERSION = 1;
			const STORE_NAME = 'checkHistory';
			
			let db = null;
			
			// Initialize IndexedDB
			async function initDB() {
				return new Promise((resolve, reject) => {
					const request = indexedDB.open(DB_NAME, DB_VERSION);
			
					request.onerror = () => reject(request.error);
					request.onsuccess = () => {
						db = request.result;
						resolve(db);
					};
			
					request.onupgradeneeded = (event) => {
						const database = event.target.result;
						if (!database.objectStoreNames.contains(STORE_NAME)) {
							const store = database.createObjectStore(STORE_NAME, {
								keyPath: 'id',
								autoIncrement: true
							});
							store.createIndex('timestamp', 'timestamp', {
								unique: false
							});
							store.createIndex('filename', 'filename', {
								unique: false
							});
						}
					};
				});
			}
			
			// Generate filename based on email count and date
			function generateFilename(emailCount) {
				const now = new Date();
				const dateStr = now.toISOString().slice(0, 10).replace(/-/g, '-');
				const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '-');
				return `History-${emailCount}emails-BulkGmailChecker_${dateStr}_${timeStr}`;
			}
			
			// Save check results to IndexedDB
			async function saveCheckHistory(results) {
				if (!db) await initDB();
			
				try {
					const transaction = db.transaction([STORE_NAME], 'readwrite');
					const store = transaction.objectStore(STORE_NAME);
			
					const historyItem = {
						timestamp: Date.now(),
						filename: generateFilename(results.length),
						emailCount: results.length,
						results: results,
						stats: {
							live: results.filter(item => item.status === 'live').length,
							verify: results.filter(item => item.status === 'verify').length,
							disabled: results.filter(item => item.status === 'disabled').length,
							unregistered: results.filter(item => item.status === 'unregistered').length,
							error: results.filter(item => item.status === 'error').length
						}
					};
			
					const request = store.add(historyItem);
			
					return new Promise((resolve, reject) => {
						request.onsuccess = () => resolve(request.result);
						request.onerror = () => reject(request.error);
					});
				} catch (error) {
					console.error('Error saving history:', error);
					throw error;
				}
			}
			
			// Get all history items
			async function getAllHistory() {
				if (!db) await initDB();
			
				return new Promise((resolve, reject) => {
					const transaction = db.transaction([STORE_NAME], 'readonly');
					const store = transaction.objectStore(STORE_NAME);
					const index = store.index('timestamp');
					const request = index.openCursor(null, 'prev'); // Get newest first
			
					const historyItems = [];
			
					request.onsuccess = (event) => {
						const cursor = event.target.result;
						if (cursor) {
							historyItems.push(cursor.value);
							cursor.continue();
						} else {
							resolve(historyItems);
						}
					};
			
					request.onerror = () => reject(request.error);
				});
			}
			
			// Get specific history item by ID
			async function getHistoryItem(id) {
				if (!db) await initDB();
			
				return new Promise((resolve, reject) => {
					const transaction = db.transaction([STORE_NAME], 'readonly');
					const store = transaction.objectStore(STORE_NAME);
					const request = store.get(id);
			
					request.onsuccess = () => resolve(request.result);
					request.onerror = () => reject(request.error);
				});
			}
			
			// Delete history item
			async function deleteHistoryItem(id) {
				if (!db) await initDB();
			
				return new Promise((resolve, reject) => {
					const transaction = db.transaction([STORE_NAME], 'readwrite');
					const store = transaction.objectStore(STORE_NAME);
					const request = store.delete(id);
			
					request.onsuccess = () => resolve();
					request.onerror = () => reject(request.error);
				});
			}
			
			// Clear all history
			async function clearAllHistory() {
				if (!db) await initDB();
			
				return new Promise((resolve, reject) => {
					const transaction = db.transaction([STORE_NAME], 'readwrite');
					const store = transaction.objectStore(STORE_NAME);
					const request = store.clear();
			
					request.onsuccess = () => resolve();
					request.onerror = () => reject(request.error);
				});
			}
			
			// Format date for display
			function formatDate(timestamp) {
				const date = new Date(timestamp);
				return date.toLocaleString();
			}
			
			// Load and display history in modal
			async function loadHistory() {
				try {
					// Tunggu sebentar untuk memastikan DOM sudah siap
					await new Promise(resolve => setTimeout(resolve, 50));
			
					const historyList = document.getElementById('history-list');
					const totalChecksEl = document.getElementById('total-checks');
					const totalEmailsEl = document.getElementById('total-emails');
			
					// Validasi elemen exist
					if (!historyList || !totalChecksEl || !totalEmailsEl) {
						console.error('History elements not found in DOM');
			
						// Coba buat ulang modal jika elemen tidak ditemukan
						if (!myAccountModal) {
							await createMyAccountModal();
							// Coba lagi setelah modal dibuat ulang
							return await loadHistory();
						}
						return;
					}
			
					historyList.innerHTML = '<p>Loading history...</p>';
			
					const historyItems = await getAllHistory();
			
					// Update stats
					totalChecksEl.textContent = `Total: ${historyItems.length}`;
					const totalEmails = historyItems.reduce((sum, item) => sum + item.emailCount, 0);
					totalEmailsEl.textContent = `Emails: ${totalEmails}`;
			
					if (historyItems.length === 0) {
						historyList.innerHTML = `
							<div class="empty-history">
								<i class="fas fa-history fa-2x" style="margin-bottom: 10px;"></i>
								<p>No check history found</p>
								<p style="font-size: 0.9em;">Your check results will appear here</p>
							</div>
						`;
						return;
					}
			
					let html = '';
					historyItems.forEach(item => {
						html += `
							<div class="history-item" data-id="${item.id}">
								<div class="history-info">
									<div class="history-filename">${item.filename}</div>
									<div class="history-meta">
										<span>${formatDate(item.timestamp)}</span>
										<span>${item.emailCount} emails</span>
										<span>Live: ${item.stats.live}</span>
										<span>Verify: ${item.stats.verify}</span>
										<span>Disabled: ${item.stats.disabled}</span>
									</div>
								</div>
								<div class="history-actions">
									<button class="history-btn open" title="Open in results">
										<i class="fas fa-folder-open"></i>
									</button>
									<button class="history-btn copy" title="Copy results">
										<i class="fas fa-copy"></i>
									</button>
									<button class="history-btn download" title="Download results">
										<i class="fas fa-download"></i>
									</button>
									<button class="history-btn delete" title="Delete history">
										<i class="fas fa-trash"></i>
									</button>
								</div>
							</div>
						`;
					});
			
					historyList.innerHTML = html;
			
					// Add event listeners to history buttons
					document.querySelectorAll('.history-item').forEach(item => {
						const id = parseInt(item.dataset.id);
			
						item.querySelector('.history-btn.open').addEventListener('click', () => openHistoryItem(id));
						item.querySelector('.history-btn.copy').addEventListener('click', () => copyHistoryItem(id));
						item.querySelector('.history-btn.download').addEventListener('click', () => downloadHistoryItem(id));
						item.querySelector('.history-btn.delete').addEventListener('click', () => deleteHistoryItemUI(id));
					});
			
				} catch (error) {
					console.error('Error loading history:', error);
			
					// Fallback: coba tampilkan error di modal jika mungkin
					const historyList = document.getElementById('history-list');
					if (historyList) {
						historyList.innerHTML = '<p class="status-error">Error loading history</p>';
					}
				}
			}
			
			// Open history item in main results
			async function openHistoryItem(id) {
				try {
					const historyItem = await getHistoryItem(id);
					if (!historyItem) {
						alert('History item not found');
						return;
					}
			
					// Set the results to the history item results
					results = historyItem.results;
			
					// Update UI
					updateCounters();
					displayResults();
			
					// Show output section
					inputSection.classList.add('hidden');
					outputSection.classList.remove('hidden');
					inputButtonContainer.classList.add('hidden');
					outputButtonContainer.classList.remove('hidden');
			
					// Close modal
					closeMyAccountModal();
			
					// Show success message
					systemMessage.textContent = `${historyItem.filename}`;
			
				} catch (error) {
					console.error('Error opening history item:', error);
					alert('Failed to open history item');
				}
			}
			
			// Copy history item results
			async function copyHistoryItem(id) {
				try {
					const historyItem = await getHistoryItem(id);
					if (!historyItem) {
						alert('History item not found');
						return;
					}
			
					const textToCopy = historyItem.results.map(item => item.email).join('\n');
			
					await navigator.clipboard.writeText(textToCopy);
			
					// Show feedback
					const copyBtn = event.target.closest('.history-btn.copy');
					const originalHtml = copyBtn.innerHTML;
					copyBtn.innerHTML = '<i class="fas fa-check"></i>';
					copyBtn.style.backgroundColor = 'rgba(0, 255, 127, 0.4)';
			
					setTimeout(() => {
						copyBtn.innerHTML = originalHtml;
						copyBtn.style.backgroundColor = '';
					}, 2000);
			
				} catch (error) {
					console.error('Error copying history item:', error);
					alert('Failed to copy history item');
				}
			}
			
			// Download history item
			async function downloadHistoryItem(id) {
				try {
					const historyItem = await getHistoryItem(id);
					if (!historyItem) {
						alert('History item not found');
						return;
					}
			
					const textToDownload = historyItem.results.map(item => item.email).join('\n');
					const blob = new Blob([textToDownload], {
						type: 'text/plain'
					});
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = `${historyItem.filename}.txt`;
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);
					URL.revokeObjectURL(url);
			
				} catch (error) {
					console.error('Error downloading history item:', error);
					alert('Failed to download history item');
				}
			}
			
			// Delete history item from UI and database
			async function deleteHistoryItemUI(id) {
				if (!confirm('Are you sure you want to delete this history item?')) {
					return;
				}
			
				try {
					await deleteHistoryItem(id);
			
					// Remove from UI
					const historyItem = document.querySelector(`.history-item[data-id="${id}"]`);
					if (historyItem) {
						historyItem.style.opacity = '0.5';
						setTimeout(() => {
							historyItem.remove();
							// Reload history to check if empty
							loadHistory();
						}, 300);
					}
			
				} catch (error) {
					console.error('Error deleting history item:', error);
					alert('Failed to delete history item');
				}
			}
			
			// Clear all history
			async function clearAllHistoryUI() {
				if (!confirm('Are you sure you want to clear all history? This action cannot be undone.')) {
					return;
				}
			
				try {
					await clearAllHistory();
					await loadHistory(); // Reload empty history
				} catch (error) {
					console.error('Error clearing history:', error);
					alert('Failed to clear history');
				}
			}
			
			// Initialize database when app starts
			async function initHistorySystem() {
				try {
					await initDB();
				} catch (error) {
					console.error('Failed to initialize history system:', error);
				}
			}
			
			// Update the save function to be called after execution
			// Add this to the EXECUTE function after results are complete
			async function saveCurrentResults() {
				if (results && results.length > 0) {
					try {
						await saveCheckHistory(results);
					} catch (error) {
						console.error('Failed to save results to history:', error);
					}
				}
			}
		</script>
		<script id="loading-system">
			const docBody = document.body;
			const docHead = document.head;
			const CACHE_DURATION = 864e5;
			const VISITED_KEY = 'gc_user_visited_before';
			
			const cacheUtils = {
				set: (key, value) => {
					try {
						const data = {
							data: value,
							timestamp: Date.now()
						};
						localStorage.setItem(key, JSON.stringify(data));
						return true;
					} catch (error) {
						console.warn("LocalStorage set failed:", error);
						return false;
					}
				},
				get: key => {
					try {
						const item = localStorage.getItem(key);
						if (!item) return null;
						const data = JSON.parse(item);
						return Date.now() - data.timestamp > CACHE_DURATION ? 
							(localStorage.removeItem(key), null) : data.data;
					} catch (error) {
						console.warn("LocalStorage get failed:", error);
						return null;
					}
				},
				remove: key => {
					try {
						localStorage.removeItem(key);
						return true;
					} catch (error) {
						console.warn("LocalStorage remove failed:", error);
						return false;
					}
				}
			};
			
			function createLoadingAnimation(duration = 'slow') {
				const loadingOverlayID = 'loading-overlay-5161774';
				let animationDurationMs;
				let progressBarAnimationDuration;
				let typingAnimationDuration;
			
				// Tentukan durasi berdasarkan parameter
				if (duration === 'slow') {
					animationDurationMs = 3500;
					progressBarAnimationDuration = '1.5s';
					typingAnimationDuration = '1.5s';
				} else if (duration === 'normal') {
					animationDurationMs = 2000;
					progressBarAnimationDuration = '1s';
					typingAnimationDuration = '1s';
				} else if (duration === 'fast') {
					animationDurationMs = 750;
					progressBarAnimationDuration = '0.5s';
					typingAnimationDuration = '0.5s';
				}
			
				// Hapus loading overlay yang mungkin sudah ada
				const existingOverlay = document.getElementById(loadingOverlayID);
				if (existingOverlay) {
					existingOverlay.remove();
				}
				
				const css = `
					#loading-overlay-5161774 {
						background: radial-gradient(circle, rgba(26, 26, 26, 1) 0%, var(--primary-red) 60%, rgba(26, 26, 26, 1) 100%);
						position: fixed;
						top: 0;
						left: 0;
						width: 100%;
						height: 100%;
						display: flex;
						justify-content: center;
						align-items: center;
						z-index: 9999;
						opacity: 1;
						transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
					}
					
					#${loadingOverlayID}.fade-out {
						opacity: 0;
						visibility: hidden;
					}
					
					#${loadingOverlayID} .loading-container {
						display: flex;
						flex-direction: column;
						gap: 10px;
						text-align: center;
						color: white;
						transform: scale(1);
						transition: transform 0.3s ease-out;
					}
					
					#${loadingOverlayID}.fade-out .loading-container {
						transform: scale(5);
					}
					
					#${loadingOverlayID} .typewriter-text {
						overflow: hidden;
						border-right: .15em solid #4CAF50;
						white-space: nowrap;
						margin: 0 auto;
						animation: 
							${loadingOverlayID}_typing ${typingAnimationDuration} steps(30,end) forwards,
							${loadingOverlayID}_blink .5s step-end infinite;
					}
					
					@keyframes ${loadingOverlayID}_typing {
						from { width: 0 }
						to { width: 100% }
					}
					
					@keyframes ${loadingOverlayID}_blink {
						from, to { border-color: transparent }
						50% { border-color: #4caf50 }
					}
					
					#${loadingOverlayID} .progress-container-loading {
						width: 100%;
						height: 10px;
						background-color: rgba(255,255,255,0.2);
						border-radius: 10px;
						margin-top: 20px;
						overflow: hidden;
						position: relative;
					}
					
					#${loadingOverlayID} .progress-bar-loading {
						height: 100%;
						width: 0;
						background: linear-gradient(90deg, red, #4CAF50);
						border-radius: 10px;
						animation: ${loadingOverlayID}_progress ${progressBarAnimationDuration} cubic-bezier(0.4, 0, 0.2, 1) forwards;
						position: relative;
						overflow: hidden;
					}
					
					#${loadingOverlayID} .progress-bar-loading::after {
						content: '';
						position: absolute;
						top: 0;
						left: 0;
						bottom: 0;
						width: 100%;
						background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
						animation: ${loadingOverlayID}_shimmer 1.5s infinite;
					}
					
					@keyframes ${loadingOverlayID}_progress {
						from { width: 0 }
						to { width: 100% }
					}
					
					@keyframes ${loadingOverlayID}_shimmer {
						0% { transform: translateX(-100%); }
						100% { transform: translateX(100%); }
					} 				
					
					.dragon-logo{
						width: 250px;
						height: 250px;
						margin-bottom: 15px;
					}
				`;
			
				const styleElement = document.createElement('style');
				styleElement.textContent = css;
				styleElement.id = 'loadingStyle';
			
				const loadingContent = document.createElement('div');
				loadingContent.classList.add('loading-content');
				loadingContent.innerHTML = `
					<div class="loading-container" id="loading-system-container">
						<div><img src="./assets/image/dragon-bulk-gmail-checker-logo.webp" class="dragon-logo" alt="bulk gmail checker logo"></div>
						<div class="typewriter-text">
							<h1 style="color: red; font-family: 'Orbitron', sans-serif;"><span style="color: #e0e0e0; opacity: 0.7;">BULK</span> GMAIL CHECKER</h1>
						</div>
						<div class="progress-container-loading" id="progress-container-loading">
							<div class="progress-bar-loading"></div>
						</div>
					</div>
				`;
				
				const loadingOverlay = document.createElement('div');
				loadingOverlay.id = loadingOverlayID;
				
				docBody.style.backgroundImage='';
				
				// Tambahkan ke DOM
				docHead.appendChild(styleElement);
				docBody.appendChild(loadingOverlay);
				loadingOverlay.appendChild(loadingContent);
			
				// Fungsi untuk menghilangkan loading dengan smooth
				const removeLoadingSmoothly = () => {
					return new Promise((resolve) => {
						// Trigger fade out animation
						loadingOverlay.classList.add('fade-out');
			
						docBody.style.backgroundImage = 'url("./assets/image/dragon-bulk-gmail-checker-background.webp")';
						
						// Hapus element setelah transisi selesai
						setTimeout(() => {
							if (loadingOverlay.parentNode) {
								loadingOverlay.remove();
							}
							if (styleElement.parentNode) {
								styleElement.parentNode.removeChild(styleElement);
							}
							resolve();
						}, 500);
					});
				};
				
				// Auto-remove setelah durasi yang ditentukan
				function convertToMilliseconds(timeStr) {
					let seconds = parseFloat(timeStr);
					return seconds * 1000;
				}
				
				const loadingProgressContainer= document.getElementById('progress-container-loading');
				const loadingSystemContainer = document.getElementById('loading-system-container');
				loadingProgressContainerMs = convertToMilliseconds(progressBarAnimationDuration)
				setTimeout(() => {
					loadingProgressContainer.classList.add('hidden');
				}, loadingProgressContainerMs);
			
				// Auto-remove setelah durasi yang ditentukan
				setTimeout(removeLoadingSmoothly, animationDurationMs);
			
				return animationDurationMs;
			}
			
			function initLoadingSystem() {
				const hasVisited = cacheUtils.get(VISITED_KEY);
				let loadingType = 'slow';
				let initDelay = 3000;
			
				if (hasVisited) {
					loadingType = 'normal';
					initDelay = 1750;
				}
			
				const actualLoadingDuration = createLoadingAnimation(loadingType);
			
				// Set visited status untuk kunjungan berikutnya
				if (!hasVisited) {
					setTimeout(() => {
						cacheUtils.set(VISITED_KEY, true);
					}, actualLoadingDuration);
				}
				
				return {
					duration: loadingType,
					initDelay
				};
			}
		</script>		
	</body>
</html>