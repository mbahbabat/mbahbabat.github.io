const errorEmailOverlay = document.getElementById("error-email-overlay"),
    errorEmailList = document.getElementById("error-email-list"),
    removeDuplicatesBtn = document.getElementById("remove-duplicates"),
    landingPage = document.getElementById("output-info-scrollable"),
    removeInvalidBtn = document.getElementById("remove-invalid"),
    appInfo = document.getElementById("app-info"),
    emailsInput = document.getElementById("emails-input"),
    actionBtn = document.getElementById("action-btn"),
    generateBtn = document.getElementById("generate-btn"),
    stopBtn = document.getElementById("stop-btn"),
    modeBtn = document.getElementById("mode-btn"),
    resetBtn = document.getElementById("reset-btn"),
    modeStatus = document.getElementById("mode-status"),
    modeSelection = document.getElementById("mode-selection"),
    selectModeH2 = document.getElementById("select-mode-h2"),
    modeSpecs = document.getElementById("mode-specs"),
    downloadAllBtn = document.getElementById("download-all"),
    emailTasksContainer = document.getElementById("email-tasks"),
    globalProgress = document.getElementById("global-progress"),
    lineNumbers = document.getElementById("line-numbers"),
    DB_NAME = "GmailDotTrickDB",
    DB_VERSION = 1,
    STORE_NAME = "emailResults",
    SERVER_URL = "https://bulk-gmail-dot-trick.mbahbabat.workers.dev",
    CACHE_DURATION = 864e5,
    cacheUtils = {
        set: (e, s) => {
            try {
                const t = {
                    data: s,
                    timestamp: Date.now()
                };
                return localStorage.setItem(e, JSON.stringify(t)), !0
            } catch (e) {
                return console.warn("LocalStorage set failed:", e), !1
            }
        },
        get: e => {
            try {
                const s = localStorage.getItem(e);
                if (!s) return null;
                const t = JSON.parse(s);
                return Date.now() - t.timestamp > 864e5 ? (localStorage.removeItem(e), null) : t.data
            } catch (e) {
                return console.warn("LocalStorage get failed:", e), null
            }
        },
        remove: e => {
            try {
                return localStorage.removeItem(e), !0
            } catch (e) {
                return console.warn("LocalStorage remove failed:", e), !1
            }
        }
    };
let MAX_CONCURRENT_TASKS, appConfig, accessToken, emailTasks = new Map,
    activeWorkers = new Map,
    isProcessing = !1,
    completedTasks = 0,
    totalTasks = 0,
    emailQueue = [],
    currentEmailQueueIndex = 0,
    currentProcessingBatch = new Set,
    isBatchCurrentlyActive = !1,
    cachedWorkerCode = null,
    db = null,
    terminatedProcess = !1;
const domHelpers = {
        show: (e, s = "block") => e.style.display = s,
        hide: e => e.style.display = "none",
        addClass: (e, s) => e.classList.add(s),
        removeClass: (e, s) => e.classList.remove(s),
        toggleClass: (e, s, t) => t ? e.classList.add(s) : e.classList.remove(s),
        setHTML: (e, s) => e.innerHTML = s,
        setText: (e, s) => e.textContent = s,
        setStyle: (e, s) => e.style.cssText = s
    },
    dbUtils = {
        open: () => new Promise(((e, s) => {
            const t = indexedDB.open(DB_NAME, 1);
            t.onerror = () => s(t.error), t.onsuccess = () => e(t.result), t.onupgradeneeded = e => {
                const s = e.target.result;
                s.objectStoreNames.contains(STORE_NAME) && s.deleteObjectStore(STORE_NAME), s.createObjectStore(STORE_NAME, {
                    keyPath: "email"
                }).createIndex("expiry", "expiry", {
                    unique: !1
                })
            }
        })),
        save: async (e, s) => (db = db || await dbUtils.open(), new Promise(((t, o) => {
            const a = db.transaction([STORE_NAME], "readwrite").objectStore(STORE_NAME),
                l = Date.now() + 72e5,
                n = {
                    email: e,
                    combinations: s.combinations,
                    compressedData: s.compressedData,
                    expiry: l,
                    timestamp: Date.now()
                },
                r = a.put(n);
            r.onerror = () => o(r.error), r.onsuccess = () => t()
        }))),
        get: async e => (db = db || await dbUtils.open(), new Promise(((s, t) => {
            const o = db.transaction([STORE_NAME], "readonly").objectStore(STORE_NAME).get(e);
            o.onerror = () => t(o.error), o.onsuccess = () => {
                const t = o.result;
                t && t.expiry > Date.now() ? s(t) : (t && dbUtils.delete(e), s(null))
            }
        }))),
        delete: async e => (db = db || await dbUtils.open(), new Promise(((s, t) => {
            const o = db.transaction([STORE_NAME], "readwrite").objectStore(STORE_NAME).delete(e);
            o.onerror = () => t(o.error), o.onsuccess = () => s()
        }))),
        getAll: async () => (db = db || await dbUtils.open(), new Promise(((e, s) => {
            const t = db.transaction([STORE_NAME], "readonly").objectStore(STORE_NAME).getAll();
            t.onerror = () => s(t.error), t.onsuccess = () => {
                const s = Date.now(),
                    o = t.result.filter((e => e.expiry > s));
                t.result.filter((e => e.expiry <= s)).forEach((e => dbUtils.delete(e.email))), e(o)
            }
        }))),
        clearAll: async () => (db = db || await dbUtils.open(), new Promise(((e, s) => {
            const t = db.transaction([STORE_NAME], "readwrite").objectStore(STORE_NAME).clear();
            t.onerror = () => s(t.error), t.onsuccess = () => e()
        }))),
        cleanupExpired: async () => (db = db || await dbUtils.open(), new Promise(((e, s) => {
            const t = db.transaction([STORE_NAME], "readwrite").objectStore(STORE_NAME).index("expiry"),
                o = IDBKeyRange.upperBound(Date.now()),
                a = t.openCursor(o);
            a.onerror = () => s(a.error), a.onsuccess = s => {
                const t = s.target.result;
                t ? (t.delete(), t.continue()) : e()
            }
        })))
    },
    modeUtils = {
        get: () => {
            let e = null;
            return document.querySelectorAll('input[name="mode"]').forEach((s => {
                s.checked && (e = s.value)
            })), e
        },
        updateSpecs: () => {
            const e = modeUtils.get();
            let s = "",
                t = "",
                o = "";
            const a = {
                fast: {
                    html: '<h3 style="color:#ff3300">Fast Mode Details</h3><p><strong style="color:#0ff;">Features:</strong></p><p><strong><i class="fa-solid fa-list-check"></i> Active Tasks:</strong> 10</p><p><strong><i class="fa-solid fa-wand-magic-sparkles"></i> Max Variations:</strong> Unlimited</p><p><strong><i class="fa-solid fa-gauge-high"></i> Speed:</strong> Up to 400,000/second</p><p><strong><i class="fa-solid fa-file-zipper"></i> File Compression:</strong> Best</p><p style="margin-top:20px"><strong style="color:#0ff">Minimum Device Spec:</strong></p><p><strong><i class="fa-solid fa-microchip"></i> CPU:</strong> 8-core, 8-thread</p><p><strong><i class="fa-solid fa-memory"></i> Memory:</strong> 16GB</p><p class="warning-message"><i class="fa-solid fa-triangle-exclamation"></i> Please select a mode that matches your device specifications. Generating a large number of combinations can be very resource-intensive and may cause your browser to crash or become unresponsive if your device is not powerful enough.</p>',
                    status: '<i class="fa-solid fa-circle" style="color:#ff3300"></i>',
                    style: "box-shadow: 0 0 3px 1px rgba(255, 99, 71, 0.8); border-left: 4px solid #ff3300;"
                },
                balance: {
                    html: '<h3 style="color:#ffff00">Balance Mode Details</h3><strong style="color:#0ff;">Features:</strong></p><p><strong><i class="fa-solid fa-list-check"></i> Active Tasks:</strong> 3</p><p><strong><i class="fa-solid fa-wand-magic-sparkles"></i> Max Variations:</strong> 2,000,000</p><p><strong><i class="fa-solid fa-gauge-high"></i> Speed:</strong> Up to 150,000/second</p><p><strong><i class="fa-solid fa-file-zipper"></i> File Compression:</strong> Normal</p><p style="margin-top:20px"><strong style="color:#0ff">Minimum Device Spec:</strong></p><p><strong><i class="fa-solid fa-microchip"></i> CPU:</strong> 4-core, 4-thread</p><p><strong><i class="fa-solid fa-memory"></i> Memory:</strong> 8GB</p>',
                    status: '<i class="fa-solid fa-circle" style="color:#ffff00"></i>',
                    style: "box-shadow: 0 0 3px 1px rgba(255, 255, 0, 0.5); border-left: 4px solid #ffff00;"
                },
                slow: {
                    html: '<h3 style="color:#53ff1a">Slow Mode Details</h3><strong style="color:#0ff;">Features:</strong></p><p><strong><i class="fa-solid fa-list-check"></i> Active Tasks:</strong> 1</p><p><strong><i class="fa-solid fa-wand-magic-sparkles"></i> Max Variations:</strong> 250,000</p><p><strong><i class="fa-solid fa-gauge-high"></i> Speed:</strong> Up to 10,000/second</p><p><strong><i class="fa-solid fa-file-zipper"></i> File Compression:</strong> Low</p><p style="margin-top:20px"><strong style="color:#0ff">Minimum Device Spec:</strong></p><p><strong><i class="fa-solid fa-microchip"></i> CPU:</strong> 2-core, 4-thread</p><p><strong><i class="fa-solid fa-memory"></i> Memory:</strong> 4GB</p>',
                    status: '<i class="fa-solid fa-circle" style="color:#53ff1a"></i>',
                    style: "box-shadow: 0 0 3px 1px rgba(0, 255, 0, 0.5); border-left: 4px solid #53ff1a;"
                }
            };
            a[e] && (s = a[e].html, t = a[e].status, o = a[e].style), domHelpers.setHTML(modeStatus, t), domHelpers.setStyle(modeSpecs, o), domHelpers.setHTML(modeSpecs, s)
        }
    },
    serverUtils = {
        getAccessToken: async () => {
            const e = await fetch(`${SERVER_URL}/get-accessToken`);
            return (await e.json()).accessToken
        },
        getConfig: async () => {
            accessToken = accessToken || await serverUtils.getAccessToken();
            const e = modeUtils.get(),
                s = await fetch(`${SERVER_URL}/get-configs`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${accessToken}`
                    },
                    body: JSON.stringify({
                        mode: e
                    })
                });
            if (!s.ok) throw new Error(`HTTP error! status: ${s.status}`);
            const t = await s.json();
            return {
                maxConcurrentTasks: t.maxConcurrentTasks,
                chunkLimit: t.chunkLimit,
                allDownloadFilename: t.allDownloadFilename,
                singleDownloadFilename: t.singleDownloadFilename,
                nextTaskDelay: t.nextTaskDelay,
                compressionLevel: t.compressionLevel,
                maxCombinationsPerEmail: t.maxCombinationsPerEmail,
                delayPerChunk: t.delayPerChunk
            }
        }
    },
    workerUtils = {
        create: async () => {
            if (!accessToken) return console.error("Unauthorized"), null;
            let e = cacheUtils.get("worker_code");
            if (!e) {
                const s = await fetch(`${SERVER_URL}/wc`, {
                    headers: {
                        Authorization: `Bearer ${accessToken}`
                    }
                });
                if (!s.ok) throw new Error("Failed to load worker code");
                e = await s.text(), cacheUtils.set("worker_code", e)
            }
            const s = new Blob([e], {
                    type: "application/javascript"
                }),
                t = URL.createObjectURL(s),
                o = new Worker(t);
            return o.onmessage = e => {
                const {
                    type: s,
                    data: t
                } = e.data;
                switch (s) {
                    case "chunk":
                        workerUtils.processChunk(t);
                        break;
                    case "error":
                        workerUtils.handleError(t.email, t.message)
                }
            }, o.onerror = e => {
                let s = null;
                for (let [e, t] of activeWorkers)
                    if (t === o) {
                        s = e;
                        break
                    } workerUtils.handleError(s, "Worker error: " + e.message)
            }, o
        },
        processChunk: e => {
            if (!accessToken) return void console.error("Unauthorized");
            const {
                combinations: s,
                total: t,
                chunk: o,
                hasMore: a,
                email: l
            } = e, n = emailTasks.get(l);
            if (!n) {
                const e = activeWorkers.get(l);
                return void(e && e.terminate())
            }
            n.combinations = [...n.combinations, ...s], n.totalCombinations = t, n.processedCount = n.combinations.length;
            const r = Math.min(100, Math.round(n.processedCount / t * 100));
            domHelpers.setStyle(n.progressBar, `width: ${r}%`), domHelpers.setText(n.progressBar, `${r}%`);
            const i = (Date.now() - n.startTime) / 1e3,
                d = Math.round(n.processedCount / i);
            domHelpers.setHTML(n.details, `<div>Generated: ${n.processedCount}/${t}</div><div>Speed: ${d}/sec</div>`), a && isProcessing && "processing" === n.status ? setTimeout((() => {
                isProcessing && emailTasks.has(l) && activeWorkers.has(l) && activeWorkers.get(l).postMessage({
                    type: "generate",
                    data: {
                        email: l,
                        chunk: o + 1,
                        limit: CHUNK_LIMIT,
                        maxCombinations: MAX_COMBINATIONS
                    }
                })
            }), CHUNK_DELAY) : workerUtils.finishTask(l), uiUtils.updateGlobalProgress()
        },
        handleError: async (e, s) => {
            appConfig || (appConfig = await serverUtils.getConfig());
            const t = emailTasks.get(e),
                o = activeWorkers.get(e);
            t ? (t.status = "error", domHelpers.setText(t.details, "Error: " + s), domHelpers.setStyle(t.progressBar, "background: #ff4d4d"), domHelpers.removeClass(t.element, "active-task"), o && (o.terminate(), activeWorkers.delete(e)), currentProcessingBatch.delete(e), completedTasks++, uiUtils.updateGlobalProgress(), 0 === currentProcessingBatch.size && isBatchCurrentlyActive && (isBatchCurrentlyActive = !1, currentEmailQueueIndex < emailQueue.length && setTimeout(taskUtils.startNextBatch, appConfig.nextTaskDelay))) : o && o.terminate()
        },
        finishTask: async e => {
            if (!accessToken) return void console.error("Unauthorized");
            appConfig || (appConfig = await serverUtils.getConfig());
            const s = emailTasks.get(e),
                t = activeWorkers.get(e);
            if (s) {
                try {
                    const t = new JSZip;
                    t.file(e + appConfig.singleDownloadFilename, s.combinations.join("\n")), domHelpers.setHTML(s.downloadBtn, '<div><i class="fa-solid fa-spinner"></i> Preparing file...</div>'), domHelpers.setHTML(s.details, `<div>Generated: ${s.processedCount}/${s.totalCombinations}</div><div>Speed: 0/sec</div>`), domHelpers.setStyle(s.taskNumber, "box-shadow: 0 0 10px 2px rgba(77, 210, 255, 0.5);color:#00ffff;");
                    const o = await t.generateAsync({
                        type: "blob",
                        compression: "DEFLATE",
                        compressionOptions: {
                            level: appConfig.compressionLevel
                        }
                    });
                    await dbUtils.save(e, {
                        combinations: s.combinations,
                        compressedData: o
                    }), s.combinations = []
                } catch (t) {
                    console.error("IndexedDB error:", t), await dbUtils.save(e, {
                        combinations: s.combinations,
                        compressedData: null
                    })
                }
                s.status = "completed", domHelpers.setStyle(s.details, "color: #66ffd9"), domHelpers.setHTML(s.details, `<i class="fa-solid fa-check"></i> Generated: ${s.totalCombinations} Variations`), domHelpers.setStyle(s.progressBar, "background: linear-gradient(90deg, #004d4d, #008080, #009999); width: 100%"), domHelpers.setHTML(s.downloadBtn, '<div title="download as TXT file"><i class="fa-solid fa-download"></i> Download (TXT)</div>'), s.downloadBtn.disabled = !1, domHelpers.removeClass(s.element, "active-task"), t && (t.terminate(), activeWorkers.delete(e)), currentProcessingBatch.delete(e), completedTasks++, uiUtils.updateGlobalProgress(), 0 === currentProcessingBatch.size && isBatchCurrentlyActive && (isBatchCurrentlyActive = !1, currentEmailQueueIndex < emailQueue.length && setTimeout(taskUtils.startNextBatch, appConfig.nextTaskDelay))
            }
        }
    },
    taskUtils = {
        create: (e, s) => {
            if (!accessToken) return console.error("Unauthorized"), null;
            const t = document.createElement("div");
            t.className = "email-task", domHelpers.setHTML(t, `<div class="email-header"><div class="task-number">${s}</div><div class="email-address">${e}</div></div><div class="email-progress"><div class="progress-bar-container"><div class="progress-bar"></div></div></div><div class="task-actions"><div class="email-details">In queue...</div><button class="download-btn" disabled><i class="fa-regular fa-clock"></i> Pending...</button></div>`);
            const o = {
                element: t,
                email: e,
                combinations: [],
                totalCombinations: 0,
                processedCount: 0,
                status: "pending",
                startTime: Date.now(),
                progressBar: t.querySelector(".progress-bar"),
                details: t.querySelector(".email-details"),
                downloadBtn: t.querySelector(".download-btn"),
                taskNumber: t.querySelector(".task-number")
            };
            return o.downloadBtn.addEventListener("click", (() => {
                downloadUtils.emailResults(e), o.downloadBtn.disabled = !0, domHelpers.setHTML(o.downloadBtn, '<i class="fa-solid fa-file-circle-check" style="color:#00ffff"></i> Downloaded')
            })), emailTasks.set(e, o), emailTasksContainer.appendChild(t), o
        },
        startNextBatch: async () => {
            if (!isProcessing || isBatchCurrentlyActive || currentEmailQueueIndex >= emailQueue.length) return;
            isBatchCurrentlyActive = !0, currentProcessingBatch.clear();
            let e = 0;
            for (; e < MAX_CONCURRENT_TASKS && currentEmailQueueIndex < emailQueue.length;) {
                const s = emailQueue[currentEmailQueueIndex],
                    t = emailTasks.get(s);
                if (t && "pending" === t.status) {
                    domHelpers.setHTML(t.downloadBtn, '<i class="fa-solid fa-hourglass-start"></i> Generating...'), t.status = "processing", t.startTime = Date.now(), domHelpers.addClass(t.element, "active-task");
                    const o = await workerUtils.create();
                    o && (activeWorkers.set(s, o), currentProcessingBatch.add(s), o.postMessage({
                        type: "generate",
                        data: {
                            email: s,
                            chunk: 0,
                            limit: CHUNK_LIMIT,
                            maxCombinations: MAX_COMBINATIONS
                        }
                    }), e++)
                }
                currentEmailQueueIndex++
            }
            uiUtils.updateGlobalProgress()
        }
    },
    uiUtils = {
        updateGlobalProgress: () => {
            if (!accessToken) return void console.error("Unauthorized");
            if (0 === totalTasks) return;
            const e = e => 1 === e ? "email" : "emails",
                s = Math.round(completedTasks / totalTasks * 100);
            if (terminatedProcess) return domHelpers.setHTML(globalProgress, `<div style="color: #ff0000"><strong>Generating process has been stopped!</strong></div><div style="margin-top:5px; color:#fff">Overall Progress: ${completedTasks}/${totalTasks} ${e(completedTasks)} completed (${s}%)</div>`), emailTasks.forEach(((e, s) => {
                "completed" !== e.status && (e.status = "canceled", domHelpers.setHTML(e.details, '<i class="fa-solid fa-ban" style="color:#ff9900"></i> Canceled'), domHelpers.setHTML(e.downloadBtn, '<i class="fa-solid fa-ban" style="color:#ff9900"></i> Failed'), e.downloadBtn.disabled = !0, domHelpers.removeClass(e.element, "active-task"))
            })), domHelpers.addClass(stopBtn, "hidden"), domHelpers.removeClass(generateBtn, "hidden"), completedTasks > 0 ? (domHelpers.setHTML(downloadAllBtn, `<span title="download all results as ZIP file"><i class="fa-solid fa-file-zipper"></i> Download ${completedTasks} ${e(completedTasks)} (ZIP)</span>`), domHelpers.setStyle(downloadAllBtn, "cursor: pointer;"), downloadAllBtn.disabled = !1) : (domHelpers.setHTML(downloadAllBtn, '<i class="fa-solid fa-circle-info"></i> No completed results to download'), domHelpers.setStyle(downloadAllBtn, "color: #999;"), downloadAllBtn.disabled = !0), resetBtn.disabled = !1, void(terminatedProcess = !1);
            domHelpers.setText(globalProgress, `Overall Progress: ${completedTasks}/${totalTasks} ${e(completedTasks)} completed (${s}%)`), completedTasks < totalTasks && uiUtils.requestScroll(), completedTasks === totalTasks && (isProcessing = !1, domHelpers.setStyle(globalProgress, "color: #fff"), domHelpers.setHTML(globalProgress, `<div style="color:#00ffff">Completed!</div><div style="margin-top:5px">Total processed: ${completedTasks} of ${totalTasks} ${e(totalTasks)}.</div>`), domHelpers.setHTML(downloadAllBtn, `<span title="download as ZIP file"><i class="fa-solid fa-file-zipper"></i> Download ${1===completedTasks?"1 result":`${completedTasks} results`} (ZIP)</span>`), domHelpers.setStyle(downloadAllBtn, "cursor: pointer"), downloadAllBtn.disabled = !1, domHelpers.removeClass(actionBtn, "hidden"), resetBtn.disabled = !1, domHelpers.setStyle(resetBtn, ""), domHelpers.addClass(stopBtn, "hidden"), domHelpers.removeClass(generateBtn, "hidden"))
        },
        scrollToActiveTask: () => {
            const e = Array.from(emailTasksContainer.children);
            for (const s of e) {
                const e = s.querySelector(".email-address"),
                    t = e ? e.textContent.trim() : null,
                    o = t ? emailTasks.get(t) : null;
                if (o && "completed" !== o.status) return void setTimeout((() => {
                    s.scrollIntoView({
                        behavior: "smooth",
                        block: "center"
                    })
                }), 100)
            }
            if (e.length > 0) {
                const s = e[e.length - 1];
                setTimeout((() => {
                    s.scrollIntoView({
                        behavior: "smooth",
                        block: "center"
                    })
                }), 100)
            }
        },
        requestScroll: () => {
            let e = !1;
            e || (e = !0, setTimeout((() => {
                uiUtils.scrollToActiveTask(), e = !1
            }), 200))
        },
        saveAs: (e, s) => {
            const t = URL.createObjectURL(e),
                o = document.createElement("a");
            o.href = t, o.download = s, document.body.appendChild(o), o.click(), setTimeout((() => {
                document.body.removeChild(o), URL.revokeObjectURL(t)
            }), 100)
        }
    },
    validationUtils = {
        isValidGmail: e => {
            const s = e.trim();
            return /^[a-zA-Z0-9]+@gmail\.com$/i.test(s)
        },
        checkDuplicates: () => {
            const e = emailsInput.value.split("\n").map((e => e.trim())).filter((e => e.length > 0 && validationUtils.isValidGmail(e))),
                s = new Set,
                t = [];
            for (const o of e) {
                const e = o.split("@")[0].replace(/\./g, "").toLowerCase();
                s.has(e) ? t.push(o) : s.add(e)
            }
            return 0 === t.length ? (domHelpers.addClass(removeDuplicatesBtn, "hidden"), validationUtils.checkInvalidEmails()) : (domHelpers.addClass(landingPage, "hidden"), domHelpers.addClass(modeSelection, "hidden"), domHelpers.addClass(modeBtn, "hidden"), domHelpers.removeClass(errorEmailOverlay, "hidden"), domHelpers.setHTML(errorEmailList, t.map((e => `<div class="duplicate-item">${e} <span style="color:#cc99ff">(Duplicate)</span></div>`)).join("")), domHelpers.setText(globalProgress, "Error: Duplicate Emails Found!"), domHelpers.setHTML(downloadAllBtn, '<i class="fa-solid fa-circle-info"></i> Invalid input!'), domHelpers.setStyle(downloadAllBtn, "background: linear-gradient(90deg, rgba(130, 72, 179, 0.5), #000); border:none; box-shadow: 0 0 5px 1px rgba(255, 99, 71, 0.8); color: #ff6600"), domHelpers.addClass(removeInvalidBtn, "hidden"), domHelpers.removeClass(removeDuplicatesBtn, "hidden"), domHelpers.addClass(generateBtn, "hidden"), domHelpers.addClass(resetBtn, "hidden"), !1)
        },
        checkInvalidEmails: () => {
            const e = emailsInput.value.split("\n").map((e => e.trim())).filter((e => e.length > 0)),
                s = [];
            for (const t of e) {
                if ((t.match(/@/g) || []).length > 1) {
                    s.push({
                        email: t,
                        msg: "Invalid email format - there is more than 1 email in 1 line"
                    });
                    continue
                }
                if (!t.includes("@")) {
                    s.push({
                        email: t,
                        msg: "Invalid email format - Missing @gmail.com"
                    });
                    continue
                }
                const [e, o] = t.split("@");
                "gmail.com" === o.toLowerCase() ? 0 === e.length ? s.push({
                    email: t,
                    msg: "Invalid email format - at least 1 character before @gmail.com"
                }) : /^[a-zA-Z0-9]+$/.test(e) || s.push({
                    email: t,
                    msg: "Invalid email address - Only letters and numbers before @gmail.com"
                }) : s.push({
                    email: t,
                    msg: "Invalid domain suffix - Only @gmail.com allowed"
                })
            }
            return 0 === s.length ? (domHelpers.addClass(errorEmailOverlay, "hidden"), domHelpers.addClass(removeInvalidBtn, "hidden"), domHelpers.removeClass(generateBtn, "hidden"), domHelpers.removeClass(resetBtn, "hidden"), domHelpers.removeClass(landingPage, "hidden"), domHelpers.removeClass(modeBtn, "hidden"), domHelpers.setText(globalProgress, ""), domHelpers.setHTML(downloadAllBtn, '<i class="fa-solid fa-circle-info"></i> Click "Generate" to start!'), domHelpers.setStyle(downloadAllBtn, "background: transparent; border:none; box-shadow: none; color: #fff"), !0) : (domHelpers.addClass(landingPage, "hidden"), domHelpers.removeClass(errorEmailOverlay, "hidden"), domHelpers.addClass(modeBtn, "hidden"), domHelpers.addClass(modeSelection, "hidden"), domHelpers.setHTML(errorEmailList, s.map((e => `<div class="invalid-item">${e.email} <span style="color:#cc99ff">(${e.msg})</span></div>`)).join("")), domHelpers.removeClass(removeInvalidBtn, "hidden"), domHelpers.setText(removeInvalidBtn, `Remove invalid ${1===s.length?"email":"emails"} to continue!`), domHelpers.setText(globalProgress, `Error: Found ${s.length} invalid ${1===s.length?"email":"emails"}`), domHelpers.addClass(generateBtn, "hidden"), domHelpers.addClass(resetBtn, "hidden"), domHelpers.setHTML(downloadAllBtn, '<i class="fa-solid fa-circle-info"></i> Invalid input!'), domHelpers.setStyle(downloadAllBtn, "background: linear-gradient(90deg, rgba(130, 72, 179, 0.5), #000); border:none; box-shadow: 0 0 5px 1px rgba(255, 99, 71, 0.8); color: #ff6600"), !1)
        }
    },
    downloadUtils = {
        emailResults: async e => {
            if (!accessToken) return void console.error("Unauthorized");
            appConfig || (appConfig = await serverUtils.getConfig());
            const s = await dbUtils.get(e);
            if (!s || !s.combinations || 0 === s.combinations.length) return void alert("No data available for " + e);
            const t = s.combinations.join("\n");
            uiUtils.saveAs(new Blob([t], {
                type: "text/plain"
            }), e + appConfig.singleDownloadFilename)
        },
        allResults: async () => {
            if (0 === completedTasks) return;
            if (!accessToken) return void console.error("Unauthorized");
            const e = document.querySelectorAll(".download-btn"),
                s = Array.from(emailTasks.values()).filter((e => "completed" === e.status)).length;
            var t;
            appConfig || (appConfig = await serverUtils.getConfig()), domHelpers.setHTML(globalProgress, '<div><i class="fa-solid fa-spinner" style="color:#fff"></i> Creating ZIP archive...</div>'), domHelpers.setStyle(globalProgress, "font-size: 1rem; color: #ffff00"), domHelpers.setStyle(downloadAllBtn, "display: flex;flex-direction: column;gap: 5px;background: rgba(0, 0, 0, 0.5);box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: #fff;padding: 5px;font-size: 0.8rem;"),domHelpers.setHTML(downloadAllBtn, `<div>Processing download <span style="color:#00ffff">${s}</span> ${t=s,1===t?"email":"emails"}...</div><div style="color: #ff3300; text-shadow: 2px 2px 5px red #000; font-weight:900"><i class="fa-regular fa-clock" style="color:#fff"></i> This process may take a few minutes!</div>`), downloadAllBtn.disabled = !0, resetBtn.disabled = !0, e.forEach((e => {
                e.disabled = !0
            }));
            const o = await dbUtils.getAll();
            if (0 === o.length) return alert("No completed email data to download."), resetBtn.disabled = !1, downloadAllBtn.disabled = !1, domHelpers.setHTML(downloadAllBtn, `<span title="download all results as ZIP file"><i class="fa-solid fa-file-zipper"></i> Download ${1===s?"1 result":`${s} results`} (ZIP)</span>`), void domHelpers.setStyle(downloadAllBtn, "color: #fff");
            try {
                const s = o.map((e => {
                        if (e.compressedData) return {
                            name: e.email + appConfig.singleDownloadFilename.replace(".txt", ".zip"),
                            lastModified: new Date,
                            input: e.compressedData
                        };
                        {
                            const s = e.combinations.join("\n");
                            return {
                                name: e.email + appConfig.singleDownloadFilename,
                                lastModified: new Date,
                                input: s
                            }
                        }
                    })),
                    {
                        downloadZip: t
                    } = await import("../lib/clientZip.js"),
                    a = await t(s).blob(),
                    l = new Date;
                uiUtils.saveAs(a, `${o.length}-Gmail_Dot_Tricks-${l.toLocaleDateString()}-${l.toLocaleTimeString().replace(/:/g,"-")}.zip`), e.forEach((e => {
                    domHelpers.setHTML(e, '<i class="fa-solid fa-file-circle-check" style="color:#00ffff"></i> Downloaded')
                })), resetBtn.disabled = !1, domHelpers.setText(globalProgress, ""), domHelpers.setStyle(globalProgress, ""), domHelpers.setStyle(downloadAllBtn, ""), domHelpers.setStyle(downloadAllBtn, "color: #fff"), domHelpers.setHTML(downloadAllBtn, `<i class="fa-solid fa-circle-info"></i> successfully downloaded <span style="color:#00ffff">${1===o.length?"1 result":`${o.length} results`}!`), await dbUtils.clearAll(), resetUtils.task()
            } catch (e) {
                console.error("Error creating ZIP file:", e), domHelpers.setText(downloadAllBtn, "Error creating ZIP file. Please try again."), downloadAllBtn.disabled = !1
            }
        }
    },
    inputUtils = {
        verify: () => {
            const e = emailsInput.value.split("\n").some((e => e.trim().length > 0));
            domHelpers.setStyle(downloadAllBtn, "background:transparent; border:none; box-shadow:none; color: #fff"), domHelpers.setHTML(downloadAllBtn, '<i class="fa-solid fa-spinner"></i> Validating input...'), domHelpers.setText(globalProgress, "Please wait..."), setTimeout((() => {
                e ? (validationUtils.checkInvalidEmails(), validationUtils.checkDuplicates()) : (generateBtn.style.color = "", generateBtn.disabled = !0, domHelpers.removeClass(generateBtn, "hidden"), domHelpers.removeClass(resetBtn, "hidden"), domHelpers.removeClass(landingPage, "hidden"), domHelpers.removeClass(modeBtn, "hidden"), domHelpers.addClass(removeDuplicatesBtn, "hidden"), domHelpers.setStyle(downloadAllBtn, "background: linear-gradient(90deg, rgba(130, 72, 179, 0.5), #000); border:none; box-shadow: 0 0 5px 1px rgba(255, 190, 0, 0.5); color: #ffeb99"), domHelpers.setHTML(downloadAllBtn, '<i class="fa-solid fa-circle-info"></i> Please enter an email!'), domHelpers.setText(globalProgress, "Input is empty!"), domHelpers.addClass(errorEmailOverlay, "hidden"), domHelpers.addClass(removeInvalidBtn, "hidden"))
            }), 500)
        },
        handleValue: () => {
            emailsInput.value.split("\n").some((e => e.trim().length > 0)) ? (domHelpers.setHTML(downloadAllBtn, '<i class="fa-solid fa-circle-info"></i> Click "Generate" to start!'), generateBtn.style.color = "#00ffff", generateBtn.disabled = !1, domHelpers.setText(globalProgress, ""), domHelpers.setStyle(downloadAllBtn, "background: transparent; border:none; box-shadow: none; color: #fff")) : (domHelpers.setStyle(downloadAllBtn, "background: transparent; border:none; box-shadow: none;color:#9999ff; font-weight: 200"), generateBtn.style.color = "", generateBtn.disabled = !0, domHelpers.setText(downloadAllBtn, "Waiting for result..."))
        },
        updateLineNumbers: () => {
            const e = emailsInput.value.split("\n");
            let s = "";
            for (let t = 1; t <= Math.max(1, e.length); t++) s += t + "<br>";
            domHelpers.setHTML(lineNumbers, s), emailsInput.scrollTop = emailsInput.scrollHeight
        }
    },
    resetUtils = {
        indexedDb: async () => {
            try {
                await dbUtils.open(), await dbUtils.clearAll(), await dbUtils.cleanupExpired()
            } catch (e) {
                console.error("indexedDB cleanup failed:", e)
            }
        },
        input: () => {
            emailsInput.value = "", emailsInput.readOnly = !1, emailsInput.addEventListener("input", (() => {
                inputUtils.handleValue(), inputUtils.updateLineNumbers()
            })), inputUtils.handleValue(), inputUtils.updateLineNumbers()
        },
        ui: () => {
            setTimeout((() => {
                appInfo.scrollIntoView({
                    behavior: "smooth",
                    block: "center"
                })
            }), 100), domHelpers.removeClass(downloadAllBtn, "hidden"), domHelpers.removeClass(generateBtn, "hidden"), domHelpers.addClass(stopBtn, "hidden"), domHelpers.setStyle(downloadAllBtn, "background: transparent; border:none; box-shadow: none;color:#9999ff; font-weight: 200"), domHelpers.setStyle(resetBtn, ""), domHelpers.setStyle(generateBtn, ""), domHelpers.setStyle(globalProgress, "color: #ffeb99"), domHelpers.setHTML(emailTasksContainer, ""), domHelpers.addClass(emailTasksContainer, "hidden"), domHelpers.removeClass(landingPage, "hidden"), domHelpers.addClass(modeSelection, "hidden"), generateBtn.disabled = !0, resetBtn.disabled = !1, modeBtn.disabled = !1, domHelpers.setStyle(modeBtn, ""), domHelpers.setText(globalProgress, "")
        },
        task: () => {
            isProcessing = !1;
            for (let e of activeWorkers.values()) e.terminate();
            activeWorkers.clear(), emailTasks.clear(), emailQueue = [], currentProcessingBatch.clear(), isBatchCurrentlyActive = !1, completedTasks = 0, totalTasks = 0, currentEmailQueueIndex = 0, terminatedProcess = !1
        },
        all: async () => {
            await resetUtils.indexedDb(), resetUtils.input(), resetUtils.task(), resetUtils.ui(), modeUtils.get(), modeUtils.updateSpecs()
        }
    };
async function initDotTrick() {
    await resetUtils.all()
}

function setupEventListeners() {
    generateBtn.addEventListener("click", (async function() {
        if (isProcessing) return;
        if (!validationUtils.checkDuplicates() || !validationUtils.checkInvalidEmails()) return inputUtils.verify(), void emailsInput.addEventListener("input", (() => {
            inputUtils.verify(), inputUtils.updateLineNumbers()
        }));
        generateBtn.disabled = !0, domHelpers.setStyle(generateBtn, ""), resetBtn.disabled = !0, modeBtn.disabled = !0;
        const e = emailsInput.value.split("\n").map((e => e.trim())).filter((e => e.length > 0));
        if (0 !== e.length) {
            appConfig || (appConfig = await serverUtils.getConfig()), CHUNK_DELAY = appConfig.delayPerChunk, MAX_COMBINATIONS = appConfig.maxCombinationsPerEmail, MAX_CONCURRENT_TASKS = appConfig.maxConcurrentTasks, CHUNK_LIMIT = appConfig.chunkLimit, emailTasks.clear();
            for (let e of activeWorkers.values()) e.terminate();
            activeWorkers.clear(), emailsInput.readOnly = !0, domHelpers.addClass(modeSelection, "hidden"), domHelpers.addClass(landingPage, "hidden"), domHelpers.removeClass(emailTasksContainer, "hidden"), currentProcessingBatch.clear(), isBatchCurrentlyActive = !1, completedTasks = 0, totalTasks = e.length, currentEmailQueueIndex = 0, isProcessing = !0, downloadAllBtn.disabled = !0, domHelpers.setStyle(downloadAllBtn, "background: linear-gradient(90deg, rgba(130, 72, 179, 0.5), #000); border:none; box-shadow: 0 0 5px 1px rgba(187, 67, 255, 0.7)"), domHelpers.setHTML(downloadAllBtn, '<i class="fa-solid fa-envelope"></i> <strong> Generating...</strong>'), domHelpers.setText(globalProgress, `Starting ${totalTasks} email ${1===totalTasks?"task":"tasks"}...`), emailQueue = [], e.forEach(((e, s) => {
                taskUtils.create(e, s + 1), emailQueue.push(e)
            })), setTimeout((() => {
                isProcessing && (domHelpers.removeClass(stopBtn, "hidden"), domHelpers.addClass(generateBtn, "hidden"))
            }), 2e3), taskUtils.startNextBatch(), uiUtils.updateGlobalProgress()
        } else alert("Please enter at least one email!")
    })), stopBtn.addEventListener("click", (async function() {
        for (let e of activeWorkers.values()) e.terminate();
        activeWorkers.clear(), isProcessing = !1, currentProcessingBatch.clear(), isBatchCurrentlyActive = !1, currentEmailQueueIndex = 0, terminatedProcess = !0, uiUtils.updateGlobalProgress()
    })), resetBtn.addEventListener("click", initDotTrick), downloadAllBtn.addEventListener("click", downloadUtils.allResults), emailsInput.addEventListener("scroll", (function() {
        lineNumbers.scrollTop = this.scrollTop
    })), removeDuplicatesBtn.addEventListener("click", (async function() {
        const e = emailsInput.value.split("\n").map((e => e.trim())).filter((e => e.length > 0)),
            s = new Set,
            t = [],
            o = /^[a-zA-Z0-9]+@gmail\.com$/i;
        e.forEach((e => {
            if (!o.test(e) || e.split("@")[0].includes("+") || e.split("@")[0].includes(".")) t.push(e);
            else {
                const o = e.toLowerCase().split("@")[0].replace(/\./g, "").split("+")[0];
                s.has(o) || (s.add(o), t.push(e))
            }
        })), emailsInput.value = t.join("\n"), inputUtils.verify(), inputUtils.updateLineNumbers(), domHelpers.addClass(errorEmailOverlay, "hidden"), domHelpers.addClass(removeDuplicatesBtn, "hidden")
    })), removeInvalidBtn.addEventListener("click", (async function() {
        const e = emailsInput.value.split("\n").map((e => e.trim())).filter((e => e.length > 0)),
            s = [];
        for (const t of e) {
            if ((t.match(/@/g) || []).length > 1) continue;
            if (!t.includes("@")) continue;
            const [e, o] = t.split("@");
            "gmail.com" === o.toLowerCase() && e.length > 0 && /^[a-zA-Z0-9]+$/.test(e) && s.push(t)
        }
        emailsInput.value = s.join("\n"), inputUtils.verify(), inputUtils.updateLineNumbers(), domHelpers.addClass(errorEmailOverlay, "hidden"), domHelpers.addClass(removeInvalidBtn, "hidden")
    })), modeBtn.addEventListener("click", (function() {
        setTimeout((() => {
            selectModeH2.scrollIntoView({
                behavior: "smooth",
                block: "center"
            })
        }), 100), domHelpers.removeClass(modeSelection, "hidden"), domHelpers.addClass(landingPage, "hidden"), modeUtils.updateSpecs()
    })), window.addEventListener("resize", inputUtils.updateLineNumbers), document.addEventListener("visibilitychange", inputUtils.updateLineNumbers), document.querySelectorAll('input[name="mode"]').forEach((e => {
        e.addEventListener("change", (() => {
            appConfig = null, modeUtils.get(), modeUtils.updateSpecs()
        }))
    }))
}
setupEventListeners(), initDotTrick();