<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Gmail Dot Trick Generator - Multiple Emails Batch Tool</title>
		<!-- SEO & Open Graph -->
		<meta name="description" content="Instantly generate thousands of Gmail dot variations in bulk — super fast, secure, and 100% free. Create unlimited email aliases in seconds">

		<meta name="keywords" content="gmail dot trick, generate gmail dots, email alias generator, gmail variations, dot trick gmail, gmail dot generator, bulk email generator, fast gmail aliases, create email aliases, unlimited email variations, instant dot trick, gmail dot trick generator, bulk gmail dot generator, fast gmail alias generator, instant email variation tool, generate thousands of gmail variations, bulk email alias tool">

		<meta name="author" content="Gmooy">
		<meta name="robots" content="index, follow">

		<!-- Open Graph / Social Sharing -->
		<meta property="og:title" content="Gmail Dot Trick Generator">
		<meta property="og:description" content="Turn one email into thousands with Gmail dot tricks — bulk-processed in seconds. Perfect for privacy, tracking, and beating spam. Try it free!">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://mbahbabat.github.io/gmail-dot-trick">
		<meta property="og:image" content="./assets/pic/logo/logo-app.jpeg">
		<meta property="og:site_name" content="Gmail Dot Trick Generator">

		<!-- Twitter -->
		<meta name="twitter:card" content="summary_large_image">
		<meta name="twitter:site" content="@gmaildot">
		<meta name="twitter:title" content="Gmail Dot Trick Generator">
		<meta name="twitter:description" content="Bulk-generate Gmail dot variations in seconds — no login, no wait. Create unlimited email aliases for any purpose.">
		<meta name="twitter:image" content="./assets/pic/logo/logo-app.jpeg">

		<!-- Favicon & Theme -->
		<link rel="icon" href="./assets/pic/logo/fav.ico">
		<link rel="canonical" href="https://mbahbabat.github.io/gmail-dot-trick" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css">
		<link rel="stylesheet" href="./assets/css/style-app.css">	

		<!-- Google Tag Manager -->
		<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
		new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
		j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
		'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
		})(window,document,'script','dataLayer','GTM-WL5W26CK');</script>
		
		<!-- Google tag (gtag.js) -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-MEN0ZCSX98"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'G-MEN0ZCSX98');
		</script>
		
		<script type="application/ld+json">
		{
		  "@context": "https://schema.org",
		  "@type": "WebApplication",
		  "name": "Gmail Dot Trick Generator",
		  "description": "Generate thousands of Gmail dot variations instantly in bulk. Super-fast, secure, and free. Create unlimited email aliases in seconds",
		  "applicationCategory": "Utilities",
		  "operatingSystem": "Any",
		  "offers": {
			"@type": "Offer",
			"price": "0",
			"priceCurrency": "USD"
		  },
		  "creator": {
			"@type": "Person",
			"name": "Gmooy"
		  },
		  "url": "https://mbahbabat.github.io/gmail-dot-trick",
		  "logo": "./assets/pic/logo/logo-app.jpeg"
		}
		</script>

		<script type="application/ld+json">
		{
		  "@context": "https://schema.org",
		  "@type": "FAQPage",
		  "mainEntity": [
			{
			  "@type": "Question",
			  "name": "How fast can it generate Gmail dot variations?",
			  "acceptedAnswer": {
				"@type": "Answer",
				"text": "It generates thousands of variations per second using bulk processing — each email is handled almost instantly"
			  }
			},
			{
			  "@type": "Question",
			  "name": "Is it safe to use?",
			  "acceptedAnswer": {
				"@type": "Answer",
				"text": "Yes! All processing happens in your browser. No email data is stored or sent to servers."
			  }
			}
		  ]
		}
		</script>	
	</head>
	<body>

		<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WL5W26CK"
		height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

		<div class="background-glow"></div>
		<header>
		<h2><img class="logo-app" src="./assets/pic/logo/logo-app.jpeg"> Gmail Dot Trick Generator</h2>
		<p>Advanced Gmail Dot Generator – Bulk Process, Super Fast & Instant Results</p>
		</header>
		<main>
			<div class="input-section">
				<p><i class="fa-solid fa-envelope-open-text"></i> Email input</p>
				<div class="textarea-container">
					<div class="line-numbers" id="line-numbers">1</div>
					<textarea id="emails-input" placeholder="Enter emails, one per line..."></textarea>
				</div>
			</div>
			<div class="action-btn">
				<button id="reset">Reset</button>
				<button id="generate">Generate</button>
				<button id="remove-duplicates" class="hidden">Remove duplicates to continue!</button>
				<button id="remove-invalid" class="hidden">Remove invalid emails to continue!</button>
			</div>
			<div class="output-section" id="output-section">
				<div class="error-email-overlay hidden" id="error-email-overlay">
					<div id="error-email-list"></div>
				</div>				
				<div id="output-info" class="output-info">
					<p>Waiting for results...</p>
				</div>
				<div id="email-tasks" class="email-tasks hidden"></div>					
			</div>
			<div class="global-progress" id="global-progress"></div>
			<div class="output-btn">
				<button id="download-all" disabled></button>
			</div>
		</main>
		<footer><p>&copy; 2025 Gmooy. All rights reserved.</p></footer>
		
		<script src="./assets/js/lib/jszip.min.js"></script>
		<script src="./assets/js/lib/FileSaver.min.js"></script>
		<script type="module" src="./assets/js/init/init-RDS.js"></script>
		<script>
const errorEmailOverlay = document.getElementById("error-email-overlay"),
   errorEmailList = document.getElementById("error-email-list"),
   removeDuplicatesBtn = document.getElementById("remove-duplicates"),
   outputInfo = document.getElementById("output-info"),
   removeInvalidBtn = document.getElementById("remove-invalid"),
   emailsInput = document.getElementById("emails-input"),
   generateBtn = document.getElementById("generate"),
   resetBtn = document.getElementById("reset"),
   downloadAllBtn = document.getElementById("download-all"),
   emailTasksContainer = document.getElementById("email-tasks"),
   globalProgress = document.getElementById("global-progress"),
   lineNumbers = document.getElementById("line-numbers");
let MAX_CONCURRENT_TASKS, tempToken, appConfig, accessToken, emailTasks = new Map,
   activeWorkers = new Map,
   isProcessing = !1,
   completedTasks = 0,
   totalTasks = 0,
   emailQueue = [],
   currentEmailQueueIndex = 0,
   currentProcessingBatch = new Set,
   isBatchCurrentlyActive = !1,
   cachedWorkerCode = null;
const SERVER_URL = "https://bulk-gmail-dot-trick.mbahbabat.workers.dev";
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

// Cache utility functions
const cacheUtils = {
    set: (key, data) => {
        try {
            const item = {
                data,
                timestamp: Date.now()
            };
            localStorage.setItem(key, JSON.stringify(item));
            return true;
        } catch (e) {
            console.warn("LocalStorage set failed:", e);
            return false;
        }
    },
    
    get: (key) => {
        try {
            const item = localStorage.getItem(key);
            if (!item) return null;
            
            const parsed = JSON.parse(item);
            const now = Date.now();
            
            // Check if cache is still valid
            if (now - parsed.timestamp > CACHE_DURATION) {
                localStorage.removeItem(key);
                return null;
            }
            
            return parsed.data;
        } catch (e) {
            console.warn("LocalStorage get failed:", e);
            return null;
        }
    },
    
    remove: (key) => {
        try {
            localStorage.removeItem(key);
            return true;
        } catch (e) {
            console.warn("LocalStorage remove failed:", e);
            return false;
        }
    }
};

function updateLineNumbers() {
   const e = emailsInput.value.split("\n");
   let t = "";
   for (let r = 1; r <= Math.max(1, e.length); r++) t += r + "<br>";
   lineNumbers.innerHTML = t
}
async function createWorker() {
   // Try to get worker code from cache first
   const cachedWorker = cacheUtils.get('worker_code');
   if (cachedWorker) {
       const blob = new Blob([cachedWorker], { type: 'application/javascript' });
       cachedWorkerCode = URL.createObjectURL(blob);
   } else {
       // Fetch from server if not in cache
       if (!cachedWorkerCode) {
          const e = await fetch(`${SERVER_URL}/wc`, {
             headers: {
                Authorization: `Bearer ${accessToken}`
             }
          });
          if (!e.ok) throw new Error("Failed to load worker code");
          const t = await e.text();
          
          // Cache the worker code for future use
          cacheUtils.set('worker_code', t);
          
          const blob = new Blob([t], { type: 'application/javascript' });
          cachedWorkerCode = URL.createObjectURL(blob);
       }
   }
   
   const e = new Worker(cachedWorkerCode);
   return e.onmessage = function (e) {
      const {
         type: t,
         data: r
      } = e.data;
      switch (t) {
         case "chunk":
            processWorkerChunk(r);
            break;
         case "error":
            handleWorkerError(r.email, r.message)
      }
   }, e.onerror = function (t) {
      let r = null;
      for (let [t, o] of activeWorkers)
         if (o === e) {
            r = t;
            break
         } handleWorkerError(r, "Worker error: " + t.message)
   }, e
}

function processWorkerChunk(e) {
   if (!tempToken) return void console.error("Unauthorized");
   const {
      combinations: t,
      total: r,
      chunk: o,
      hasMore: n,
      email: s
   } = e, a = emailTasks.get(s);
   if (!a) {
      const e = activeWorkers.get(s);
      return void(e && e.terminate())
   }
   a.combinations = [...a.combinations, ...t], a.totalCombinations = r, a.processedCount = a.combinations.length;
   const i = Math.min(100, Math.round(a.processedCount / r * 100));
   a.progressBar.style.width = i + "%", a.progressBar.textContent = i + "%";
   const c = (Date.now() - a.startTime) / 1e3,
      l = Math.round(a.processedCount / c);
   a.details.textContent = `Generated:${a.processedCount}/${r}| Speed:${l}/sec`, n && isProcessing && "processing" === a.status ? setTimeout(() => {
      isProcessing && emailTasks.has(s) && activeWorkers.has(s) && activeWorkers.get(s).postMessage({
         type: "generate",
         data: {
            email: s,
            chunk: o + 1,
            limit: CHUNK_LIMIT
         }
      })
   }, 1) : finishEmailTask(s), updateGlobalProgress()
}

async function handleWorkerError(e, t) {
   appConfig || (appConfig = await getConfig());
   const a = appConfig.nextTaskDelay,
      r = emailTasks.get(e),
      s = activeWorkers.get(e);
   r ? (r.status = "error", r.details.textContent = "Error: " + t, r.progressBar.style.background = "#ff4d4d", r.element.classList.remove("active-task"), s && (s.terminate(), activeWorkers.delete(e)), currentProcessingBatch.delete(e), completedTasks++, updateGlobalProgress(), 0 === currentProcessingBatch.size && isBatchCurrentlyActive && (isBatchCurrentlyActive = !1, currentEmailQueueIndex < emailQueue.length && setTimeout(startNextBatch, a))) : s && s.terminate()
}

async function finishEmailTask(e) {
   if (!tempToken) return void console.error("Unauthorized");
   appConfig || (appConfig = await getConfig());
   const t = appConfig.nextTaskDelay,
      a = emailTasks.get(e),
      r = activeWorkers.get(e);
   a && (a.status = "completed", a.details.style.color = "#66ffd9", a.details.textContent = `Generated:${a.processedCount}/ ${a.totalCombinations} emails`, a.downloadBtn.disabled = !1, a.element.classList.remove("active-task"), r && (r.terminate(), activeWorkers.delete(e)), currentProcessingBatch.delete(e), completedTasks++, updateGlobalProgress(), 0 === currentProcessingBatch.size && isBatchCurrentlyActive && (isBatchCurrentlyActive = !1, currentEmailQueueIndex < emailQueue.length && setTimeout(startNextBatch, t)))
}

function updateGlobalProgress() {
   if (!tempToken) return void console.error("Unauthorized");
   if (0 === totalTasks) return void(globalProgress.textContent = "");
   const t = Math.round(completedTasks / totalTasks * 100);
   globalProgress.textContent = `Overall Progress: ${completedTasks}/ ${totalTasks} emails completed (${t}%)`, completedTasks === totalTasks && (isProcessing = !1, globalProgress.style.color = "#fff", generateBtn.style.cssText = '', generateBtn.classList.add("hidden"), globalProgress.textContent = `All tasks completed! Generated ${completedTasks} of ${totalTasks} emails.`, downloadAllBtn.innerHTML = `<i class="fa-solid fa-file-zipper"></i> Zip all files and download!`, downloadAllBtn.style.cssText = '', resetBtn.disabled = !1, downloadAllBtn.disabled = !1)
}

function createEmailTask(t, e) {
   if (!tempToken) return void console.error("Unauthorized");
   const o = document.createElement("div");
   o.className = "email-task", taskHtml = appConfig.taskHtml, o.innerHTML = `<div class="task-number">${e}</div><div class="email-header"><span class="email-address">${t}</span></div><div class="email-progress"><div class="progress-bar-container"><div class="progress-bar">0</div></div><div class="email-details">Generated:0 / 0</div></div><div class="task-actions"><button class="download-btn" disabled><i class="fa-solid fa-download"></i>Download</button></div>`;
   const n = {
      element: o,
      email: t,
      combinations: [],
      totalCombinations: 0,
      processedCount: 0,
      status: "pending",
      startTime: Date.now(),
      progressBar: o.querySelector(".progress-bar"),
      details: o.querySelector(".email-details"),
      downloadBtn: o.querySelector(".download-btn")
   };
   return n.downloadBtn.addEventListener("click", () => {
      downloadEmailResults(t)
   }), emailTasks.set(t, n), emailTasksContainer.appendChild(o), n
}
async function downloadEmailResults(t) {
   if (!tempToken) return void console.error("Unauthorized");
   appConfig || (appConfig = await getConfig());
   const e = emailTasks.get(t);
   if (!e || 0 === e.combinations.length) return;
   const o = e.combinations.join("\n");
   saveAs(new Blob([o], {
      type: "text/plain"
   }), t + appConfig.singleDonwloadFilename)
}

function saveAs(t, e) {
   if (!tempToken) return void console.error("Unauthorized");
   const o = document.createElement("a");
   o.href = URL.createObjectURL(t), o.download = e, document.body.appendChild(o), o.click(), document.body.removeChild(o), URL.revokeObjectURL(o.href)
}
async function downloadAllResults() {
   if (0 === completedTasks) return;
   if (!tempToken) return void console.error("Unauthorized");
   const downloadButtons = document.querySelectorAll(".download-btn");
   appConfig || (appConfig = await getConfig()), globalProgress.textContent = "Processing download... this process may take a few minutes.", downloadAllBtn.style.color = "#ffff00", downloadAllBtn.disabled = !0, resetBtn.disabled = !0;
   downloadButtons.forEach(o => {
      o.disabled = !0
   });
   const t = new JSZip,
      e = appConfig.allDonwloadFilename;
   let o = 0;
   for (let [n, a] of emailTasks)
      if ("completed" === a.status && a.combinations.length > 0) {
         const s = n + e,
            r = a.combinations.join("\n");
         t.file(s, r), o++
      } if (0 === o) return alert("No completed email data to download."), resetBtn.disabled = !1, downloadAllBtn.disabled = !1, downloadAllBtn.innerHTML = `<i class="fa-solid fa-file-zipper"></i> Download all as ZIP!`, void(downloadAllBtn.style.color = "#fff");
   try {
      const e = appConfig.downloadType,
         n = appConfig.downloadCompression,
         a = appConfig.downloadCompressionOptions,
         s = await t.generateAsync({
            type: e,
            compression: n,
            compressionOptions: a
         }, function (t) {
            let e = t.percent.toFixed(2);
            downloadAllBtn.textContent = `Creating ZIP archive: ${e}%`
         }),
         r = new Date;
      downloadButtons.forEach(o => {
         o.disabled = !1
      });
      saveAs(s, `${o}-Gmail_Dot_Tricks-${r.toLocaleDateString()+"-"+r.toLocaleTimeString()}.zip`), resetBtn.disabled = !1, globalProgress.textContent = "already downloaded!", downloadAllBtn.style.color = "#fff", downloadAllBtn.textContent = `Download ${o} emails successfully!`
   } catch (t) {
      console.error("Error creating ZIP file:", t), downloadAllBtn.textContent = "Error creating ZIP file. Please try again.", downloadAllBtn.disabled = !1
   }
}
async function startNextBatch(){if(!isProcessing||isBatchCurrentlyActive||currentEmailQueueIndex>=emailQueue.length)return;isBatchCurrentlyActive=!0,currentProcessingBatch.clear();const e=emailTasks.get(emailQueue[currentEmailQueueIndex])?.element;e&&setTimeout(()=>{e.scrollIntoView({behavior:"smooth",block:"start"})},50);let t=0;for(;t<MAX_CONCURRENT_TASKS&&currentEmailQueueIndex<emailQueue.length;){const e=emailQueue[currentEmailQueueIndex],s=emailTasks.get(e);if(s&&"pending"===s.status){s.status="processing",s.startTime=Date.now(),s.element.classList.add("active-task");const n=await createWorker();activeWorkers.set(e,n),currentProcessingBatch.add(e),n.postMessage({type:"generate",data:{email:e,chunk:0,limit:CHUNK_LIMIT}}),t++}currentEmailQueueIndex++}updateGlobalProgress()}

async function getAccessToken() {
   const e = await fetch(`${SERVER_URL}/get-accessToken`);
   return (await e.json()).accessToken
}

async function getConfig() {
   accessToken || (accessToken = await getAccessToken());
   const e = await fetch(`${SERVER_URL}/get-configs`, {
      headers: {
         "Content-Type": "application/json",
         Authorization: `Bearer ${accessToken}`
      }
   });
   if (!e.ok) throw new Error(`HTTP error! status: ${e.status}`);
   const t = await e.json();
   return {
      maxConcurrentTasks: t.maxConcurrentTasks,
      chunkLimit: t.chunkLimit,
      tempToken: t.tempToken,
      downloadType: t.downloadType,
      downloadCompression: t.downloadCompression,
      downloadCompressionOptions: t.downloadCompressionOptions,
      allDonwloadFilename: t.allDonwloadFilename,
      singleDonwloadFilename: t.singleDonwloadFilename,
      nextTaskDelay: t.nextTaskDelay
   }
}

async function checkDuplicates() {
   const e = emailsInput.value.split("\n"),
      t = [],
      n = [],
      a = {},
      s = [];
   e.forEach(e => {
      const a = e.trim();
      a.length > 0 && (a.toLowerCase().includes("@gmail.com") ? t.push(a) : n.push(a))
   }), t.forEach(e => {
      const t = e.toLowerCase().replace(/\./g, "").split("+")[0];
      a[t] = (a[t] || 0) + 1, 2 === a[t] && s.push(t)
   }), s.length > 0 && (outputInfo.classList.add("hidden"), errorEmailOverlay.classList.remove("hidden"), errorEmailList.innerHTML = s.map(e => `<div class="duplicate-item">${t.filter(t=>t.toLowerCase().replace(/\./g,"").split("+")[0]===e)[0]} <span style="color:#ff6b6b">( ${a[e]-1} duplicates )</span></div>`).join(""), globalProgress.textContent = "Error: Duplicate Emails Found!", downloadAllBtn.style.cssText = "background: linear-gradient(90deg, #52527a, #000); border:none; box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: #ff6600", downloadAllBtn.textContent = "Invalid input!", removeDuplicatesBtn.classList.remove("hidden"), generateBtn.classList.add("hidden"), resetBtn.classList.add("hidden"),removeInvalidBtn.classList.add("hidden"))
}

async function checkInvalidEmails() {
   const emails = emailsInput.value.split("\n").map(email => email.trim()).filter(email => email.length > 0);
   const invalidEmails = emails.filter(email => !isValidGmail(email));
   if (invalidEmails.length > 0) {
      outputInfo.classList.add("hidden");
      errorEmailOverlay.classList.remove("hidden");
      errorEmailList.innerHTML = invalidEmails.map(email => `<div class="invalid-item">${email}<span style="color:#ff6b6b">(Invalid format)</span></div>`).join("");
      removeInvalidBtn.classList.remove("hidden");
      globalProgress.textContent = `Found ${invalidEmails.length}invalid email(s)`;
      generateBtn.classList.add("hidden");
      resetBtn.classList.add("hidden");
      downloadAllBtn.style.cssText = "background: linear-gradient(90deg, #52527a, #000); border:none; box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: #ff6600";
      downloadAllBtn.textContent = "Invalid emails!"
   } else {
      errorEmailOverlay.classList.add("hidden");
      removeInvalidBtn.classList.add("hidden");
      generateBtn.classList.remove("hidden");
      resetBtn.classList.remove("hidden");
      globalProgress.textContent = "";
      generateBtn.disabled = false;
      if (emails.length > 0) {
         generateBtn.classList.remove("hidden");
         resetBtn.classList.remove("hidden");
         downloadAllBtn.style.cssText = "background: linear-gradient(90deg, #52527a, transparent); border:none; box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: #fff";
         downloadAllBtn.textContent = "Ready to generate!"
      }
   }
}
async function handleInputValue() {
   const e = emailsInput.value.split("\n");
   let hasContent = e.some(line => line.trim().length > 0);
   downloadAllBtn.style.cssText = "background: #52527a; border:none; box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: #fff";
   downloadAllBtn.textContent = "Checking input...";
   globalProgress.textContent = "Please wait...";
   setTimeout(() => {
      if (hasContent) {
         checkInvalidEmails();
         checkDuplicates()
      } else {
         generateBtn.disabled = true;
         generateBtn.classList.remove("hidden");
         resetBtn.classList.remove("hidden");
         downloadAllBtn.textContent = "Please enter an email!";
         globalProgress.textContent = "Email input is empty...";
         errorEmailOverlay.classList.add("hidden");
         removeInvalidBtn.classList.add("hidden")
      }
   }, 500);
   updateLineNumbers()
}

function isValidGmail(e) {
   const t = e.trim().toLowerCase();
   if (!t.includes("@gmail.com")) return !1;
   if (1 !== (t.match(/@gmail\.com/g) || []).length || !t.endsWith("@gmail.com")) return !1;
   const n = t.split("@gmail.com")[0];
   return !!/^[a-zA-Z0-9]+$/.test(n)
}
async function initDotTrick() {
   emailsInput.value = "", await emailsInput.addEventListener("input", handleInputValue), await handleInputValue()
}
generateBtn.addEventListener("click", async function () {
   if (isProcessing) return;
   generateBtn.disabled = !0, resetBtn.disabled = !0;
   const e = emailsInput.value.split("\n").map(e => e.trim()).filter(e => e.length > 0);
   if (0 !== e.length) {
      appConfig || (appConfig = await getConfig()), MAX_CONCURRENT_TASKS = appConfig.maxConcurrentTasks, CHUNK_LIMIT = appConfig.chunkLimit, tempToken = appConfig.tempToken, emailTasks.clear();
      for (let e of activeWorkers.values()) e.terminate();
      activeWorkers.clear(), emailsInput.readOnly = !0, generateBtn.classList.add("hidden"), outputInfo.classList.add("hidden"), emailTasksContainer.classList.remove("hidden"), currentProcessingBatch.clear(), isBatchCurrentlyActive = !1, completedTasks = 0, totalTasks = e.length, currentEmailQueueIndex = 0, isProcessing = !0, downloadAllBtn.disabled = !0, downloadAllBtn.textContent = "Generating...", globalProgress.textContent = `Starting ${totalTasks}email tasks...`, emailQueue = [], e.forEach((e, t) => {
         createEmailTask(e, t + 1), emailQueue.push(e)
      }), startNextBatch(), updateGlobalProgress()
   } else alert("Please enter at least one email!")
}), resetBtn.addEventListener("click", function () {
   isProcessing = !1;
   for (let e of activeWorkers.values()) e.terminate();
   activeWorkers.clear(), emailTasks.clear(), emailQueue = [], currentProcessingBatch.clear(), isBatchCurrentlyActive = !1, generateBtn.textContent = "Generate", globalProgress.style.color = "#ff0", emailTasksContainer.innerHTML = "", emailTasksContainer.classList.add("hidden"), outputInfo.classList.remove("hidden"), emailsInput.readOnly = !1, emailsInput.value = "", completedTasks = 0, totalTasks = 0, currentEmailQueueIndex = 0, updateLineNumbers(), generateBtn.classList.remove("hidden"), generateBtn.disabled = !1, downloadAllBtn.disabled = !0, downloadAllBtn.innerHTML = '<i class="fa-solid fa-file-zipper"></i> Download all as zip!', globalProgress.textContent = "", initDotTrick()
}), downloadAllBtn.addEventListener("click", downloadAllResults), updateLineNumbers(), emailsInput.addEventListener("scroll", function () {
   lineNumbers.scrollTop = this.scrollTop
}), removeDuplicatesBtn.addEventListener("click", async function () {
   const e = emailsInput.value.split("\n").map(e => e.trim()).filter(e => e.length > 0),
      t = new Set,
      n = [];
   e.forEach(e => {
      if (e.toLowerCase().includes("@gmail.com")) {
         const a = e.toLowerCase().replace(/\./g, "").split("+")[0];
         t.has(a) || (t.add(a), n.push(e))
      } else n.push(e)
   }), emailsInput.value = n.join("\n"), await handleInputValue(), await checkInvalidEmails(), outputInfo.classList.remove("hidden"), errorEmailOverlay.classList.add("hidden"), removeDuplicatesBtn.classList.add("hidden")
}), removeInvalidBtn.addEventListener("click", async function () {
   const e = emailsInput.value.split("\n").map(e => e.trim()).filter(e => e.length > 0),
      t = /^[^\s@]+@gmail\.com$/i,
      n = e.filter(e => t.test(e));
   emailsInput.value = n.join("\n"), await handleInputValue(), await checkDuplicates(), outputInfo.classList.remove("hidden"), errorEmailOverlay.classList.add("hidden"), removeInvalidBtn.classList.add("hidden")
}), initDotTrick();
		</script>
	</body>
</html>