<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Gmail Dot Trick Generator - Multiple Emails Batch Tool</title>
		<!-- SEO & Open Graph -->
		<meta name="description" content="Instantly generate thousands of Gmail dot variations in bulk — super fast, secure, and 100% free. Create unlimited email aliases in seconds">

		<meta name="keywords" content="gmail dot trick, generate gmail dots, email alias generator, gmail variations, dot trick gmail, gmail dot generator, bulk email generator, fast gmail aliases, create email aliases, unlimited email variations, instant dot trick, gmail dot trick generator, bulk gmail dot generator, fast gmail alias generator, instant email variation tool, generate thousands of gmail variations, bulk email alias tool">

		<meta name="author" content="Gmooy">
		<meta name="robots" content="index, follow">

		<!-- Open Graph / Social Sharing -->
		<meta property="og:title" content="Gmail Dot Trick Generator">
		<meta property="og:description" content="Turn one email into thousands with Gmail dot tricks — bulk-processed in seconds. Perfect for privacy, tracking, and beating spam. Try it free!">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://mbahbabat.github.io/gmail-dot-trick">
		<meta property="og:image" content="./assets/pic/logo/logo-app.jpeg">
		<meta property="og:site_name" content="Gmail Dot Trick Generator">

		<!-- Twitter -->
		<meta name="twitter:card" content="summary_large_image">
		<meta name="twitter:site" content="@gmaildot">
		<meta name="twitter:title" content="Gmail Dot Trick Generator">
		<meta name="twitter:description" content="Bulk-generate Gmail dot variations in seconds — no login, no wait. Create unlimited email aliases for any purpose.">
		<meta name="twitter:image" content="./assets/pic/logo/logo-app.jpeg">

		<!-- Favicon & Theme -->
		<link rel="icon" href="./assets/pic/logo/fav.ico">
		<link rel="canonical" href="https://mbahbabat.github.io/gmail-dot-trick" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css">
		<link rel="stylesheet" href="./assets/css/style-app.css">	

		<!-- Google Tag Manager -->
		<script>!function(e,t,a,n,g){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var m=t.getElementsByTagName(a)[0],r=t.createElement(a);r.async=!0,r.src="https://www.googletagmanager.com/gtm.js?id=GTM-WL5W26CK",m.parentNode.insertBefore(r,m)}(window,document,"script","dataLayer");</script>
		
		<!-- Google tag (gtag.js) -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-T0FBXCK6YT"></script>
	    <script>
			function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-T0FBXCK6YT");
	    </script>
		
		<script type="application/ld+json">
		{
		  "@context": "https://schema.org",
		  "@type": "WebApplication",
		  "name": "Gmail Dot Trick Generator",
		  "description": "Generate thousands of Gmail dot variations instantly in bulk. Super-fast, secure, and free. Create unlimited email aliases in seconds",
		  "applicationCategory": "Utilities",
		  "operatingSystem": "Any",
		  "offers": {
			"@type": "Offer",
			"price": "0",
			"priceCurrency": "USD"
		  },
		  "creator": {
			"@type": "Person",
			"name": "Gmooy"
		  },
		  "url": "https://mbahbabat.github.io/gmail-dot-trick",
		  "logo": "./assets/pic/logo/logo-app.jpeg"
		}
		</script>

		<script type="application/ld+json">
		{
		  "@context": "https://schema.org",
		  "@type": "FAQPage",
		  "mainEntity": [
			{
			  "@type": "Question",
			  "name": "How fast can it generate Gmail dot variations?",
			  "acceptedAnswer": {
				"@type": "Answer",
				"text": "It generates thousands of variations per second using bulk processing — each email is handled almost instantly"
			  }
			},
			{
			  "@type": "Question",
			  "name": "Is it safe to use?",
			  "acceptedAnswer": {
				"@type": "Answer",
				"text": "Yes! All processing happens in your browser. No email data is stored or sent to servers."
			  }
			}
		  ]
		}
		</script>	
	</head>
	<body>

		<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WL5W26CK"
		height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

		<div class="background-glow"></div>
		<header>
		<h2><img class="logo-app" src="./assets/pic/logo/logo-app.jpeg"> Gmail Dot Trick Generator</h2>
		<p>Advanced Gmail Dot Generator – Bulk Process, Super Fast & Instant Results</p>
		</header>
		<main>
			<div class="input-section">
				<p><i class="fa-solid fa-envelope-open-text"></i> Email input</p>
				<div class="textarea-container">
					<div class="line-numbers" id="line-numbers">1</div>
					<textarea id="emails-input" placeholder="Enter emails, one per line..."></textarea>
				</div>
			</div>
			<div class="action-btn">
				<button id="reset">Reset</button>
				<button id="generate">Generate</button>
				<button id="remove-duplicates" class="hidden">Remove duplicates to continue!</button>
				<button id="remove-invalid" class="hidden">Remove invalid emails to continue!</button>
			</div>
			<div class="output-section" id="output-section">
				<div class="error-email-overlay hidden" id="error-email-overlay">
					<div id="error-email-list"></div>
				</div>				
				<div id="output-info" class="output-info">
					<p>Waiting for results...</p>
				</div>
				<div id="email-tasks" class="email-tasks hidden"></div>					
			</div>
			<div class="global-progress" id="global-progress"></div>
			<div class="output-btn">
				<button id="download-all" disabled></button>
			</div>
		</main>
		<footer><p>&copy; 2025 Gmooy. All rights reserved.</p></footer>
		
		<script src="./assets/js/lib/jszip.min.js"></script>
		<script src="./assets/js/lib/FileSaver.min.js"></script>
		<script type="module" src="./assets/js/init/init-RDS.js"></script>
		<script>
const errorEmailOverlay = document.getElementById("error-email-overlay"),
    errorEmailList = document.getElementById("error-email-list"),
    removeDuplicatesBtn = document.getElementById("remove-duplicates"),
    outputInfo = document.getElementById("output-info"),
    removeInvalidBtn = document.getElementById("remove-invalid"),
    emailsInput = document.getElementById("emails-input"),
    generateBtn = document.getElementById("generate"),
    resetBtn = document.getElementById("reset"),
    downloadAllBtn = document.getElementById("download-all"),
    emailTasksContainer = document.getElementById("email-tasks"),
    globalProgress = document.getElementById("global-progress"),
    lineNumbers = document.getElementById("line-numbers");
let MAX_CONCURRENT_TASKS, appConfig, accessToken, emailTasks = new Map,
    activeWorkers = new Map,
    isProcessing = !1,
    completedTasks = 0,
    totalTasks = 0,
    emailQueue = [],
    currentEmailQueueIndex = 0,
    currentProcessingBatch = new Set,
    isBatchCurrentlyActive = !1,
    cachedWorkerCode = null;
const SERVER_URL = "https://bulk-gmail-dot-trick.mbahbabat.workers.dev",
    CACHE_DURATION = 864e5,
    cacheUtils = {
        set: (e, t) => {
            try {
                const a = {
                    data: t,
                    timestamp: Date.now()
                };
                return localStorage.setItem(e, JSON.stringify(a)), !0
            } catch (e) {
                return console.warn("LocalStorage set failed:", e), !1
            }
        },
        get: e => {
            try {
                const t = localStorage.getItem(e);
                if (!t) return null;
                const a = JSON.parse(t);
                return Date.now() - a.timestamp > 864e5 ? (localStorage.removeItem(e), null) : a.data
            } catch (e) {
                return console.warn("LocalStorage get failed:", e), null
            }
        },
        remove: e => {
            try {
                return localStorage.removeItem(e), !0
            } catch (e) {
                return console.warn("LocalStorage remove failed:", e), !1
            }
        }
    };

// Fungsi untuk menyimpan data ke IndexedDB dengan expiry 2 jam
async function saveToIndexedDB(email, combinations) {
    if (!db) {
        db = await openDatabase();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        const expiry = Date.now() + (2 * 60 * 60 * 1000); // 2 jam dari sekarang
        const data = { 
            email, 
            combinations, 
            expiry,
            timestamp: Date.now()
        };
        
        const request = store.put(data);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
    });
}

// Fungsi untuk mengambil data dari IndexedDB berdasarkan email
async function getFromIndexedDB(email) {
    if (!db) {
        db = await openDatabase();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(email);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
            const result = request.result;
            // Periksa apakah data sudah kadaluarsa
            if (result && result.expiry > Date.now()) {
                resolve(result);
            } else {
                // Hapus data yang sudah kadaluarsa
                if (result) {
                    deleteFromIndexedDB(email);
                }
                resolve(null);
            }
        };
    });
}

// Fungsi untuk menghapus data dari IndexedDB
async function deleteFromIndexedDB(email) {
    if (!db) {
        db = await openDatabase();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(email);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
    });
}

// Fungsi untuk mengambil semua data dari IndexedDB
async function getAllFromIndexedDB() {
    if (!db) {
        db = await openDatabase();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
            const now = Date.now();
            const validData = request.result.filter(item => item.expiry > now);
            // Hapus data yang expired
            const expiredData = request.result.filter(item => item.expiry <= now);
            expiredData.forEach(item => {
                deleteFromIndexedDB(item.email);
            });
            resolve(validData);
        };
    });
}

const DB_NAME = 'GmailDotTrickDB';
const DB_VERSION = 1;
const STORE_NAME = 'emailResults';
let db = null;

function openDatabase() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        
        request.onupgradeneeded = (event) => {
            const database = event.target.result;
            
            // Hapus store lama jika ada
            if (database.objectStoreNames.contains(STORE_NAME)) {
                database.deleteObjectStore(STORE_NAME);
            }
            
            // Buat object store baru
            const store = database.createObjectStore(STORE_NAME, { keyPath: 'email' });
            // Buat index untuk expiry
            store.createIndex('expiry', 'expiry', { unique: false });
        };
    });
}

// Fungsi untuk menghapus semua data dari IndexedDB
async function clearAllIndexedDB() {
    if (!db) {
        db = await openDatabase();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.clear();
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
    });
}

// Fungsi untuk membersihkan data yang sudah kadaluarsa
async function cleanupExpiredData() {
    if (!db) {
        db = await openDatabase();
    }
    
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const index = store.index('expiry');
        const range = IDBKeyRange.upperBound(Date.now());
        const request = index.openCursor(range);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
                cursor.delete();
                cursor.continue();
            } else {
                resolve();
            }
        };
    });
}

async function getConfig() {
    accessToken || (accessToken = await getAccessToken());
    const e = await fetch(`${SERVER_URL}/get-configs`, {
        headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${accessToken}`
        }
    });
    if (!e.ok) throw new Error(`HTTP error! status: ${e.status}`);
    const t = await e.json();
    return {
        maxConcurrentTasksDesktop: t.maxConcurrentTasksDesktop,
        maxConcurrentTasksMobile: t.maxConcurrentTasksMobile,
        chunkLimit: t.chunkLimit,
        downloadType: t.downloadType,
        downloadCompression: t.downloadCompression,
        downloadCompressionOptions: t.downloadCompressionOptions,
        allDownloadFilename: t.allDownloadFilename,
        singleDownloadFilename: t.singleDownloadFilename,
        nextTaskDelay: t.nextTaskDelay
    }
}
async function getAccessToken() {
    const e = await fetch(`${SERVER_URL}/get-accessToken`);
    return (await e.json()).accessToken
}
async function handleInputValue() {
    let e = emailsInput.value.split("\n").some((e => e.trim().length > 0));
    downloadAllBtn.style.cssText = "background: #52527a; border:none; box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: #fff", downloadAllBtn.textContent = "Checking input...", globalProgress.textContent = "Please wait...", setTimeout((() => {
        e ? (checkInvalidEmails(), checkDuplicates()) : (generateBtn.disabled = !0, generateBtn.classList.remove("hidden"), resetBtn.classList.remove("hidden"), removeDuplicatesBtn.classList.add("hidden"), downloadAllBtn.textContent = "Please enter an email!", globalProgress.textContent = "Email input is empty...", errorEmailOverlay.classList.add("hidden"), removeInvalidBtn.classList.add("hidden"))
    }), 500), updateLineNumbers()
}
async function checkDuplicates() {
    const e = emailsInput.value.split("\n"),
        t = [],
        a = [],
        n = {},
        s = [];
    removeDuplicatesBtn.classList.add("hidden"), e.forEach((e => {
        const n = e.trim();
        n.length > 0 && (n.toLowerCase().includes("@gmail.com") ? t.push(n) : a.push(n))
    })), t.forEach((e => {
        const t = e.toLowerCase().replace(/\./g, "").split("+")[0];
        n[t] = (n[t] || 0) + 1, 2 === n[t] && s.push(t)
    })), s.length > 0 && (outputInfo.classList.add("hidden"), errorEmailOverlay.classList.remove("hidden"), errorEmailList.innerHTML = s.map((e => `<div class="duplicate-item">${t.find((t=>t.toLowerCase().replace(/\./g,"").split("+")[0]===e))} <span style="color:#ff6b6b">( ${n[e]-1} duplicates )</span></div>`)).join(""), globalProgress.textContent = "Error: Duplicate Emails Found!", downloadAllBtn.style.cssText = "background: linear-gradient(90deg, #52527a, #000); border:none; box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: #ff6600", downloadAllBtn.textContent = "Invalid input!", removeDuplicatesBtn.classList.remove("hidden"), generateBtn.classList.add("hidden"), resetBtn.classList.add("hidden"), removeInvalidBtn.classList.add("hidden"))
}
async function checkInvalidEmails() {
    const e = emailsInput.value.split("\n").map((e => e.trim())).filter((e => e.length > 0)),
        t = e.filter((e => !isValidGmail(e)));
    t.length > 0 ? (outputInfo.classList.add("hidden"), errorEmailOverlay.classList.remove("hidden"), errorEmailList.innerHTML = t.map((e => `<div class="invalid-item">${e}<span style="color:#ff6b6b">(Invalid format)</span></div>`)).join(""), removeInvalidBtn.classList.remove("hidden"), globalProgress.textContent = `Found ${t.length} invalid email(s)`, generateBtn.classList.add("hidden"), resetBtn.classList.add("hidden"), downloadAllBtn.style.cssText = "background: linear-gradient(90deg, #52527a, #000); border:none; box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: #ff6600", downloadAllBtn.textContent = "Invalid input!") : (errorEmailOverlay.classList.add("hidden"), removeInvalidBtn.classList.add("hidden"), generateBtn.classList.remove("hidden"), resetBtn.classList.remove("hidden"), globalProgress.textContent = "", generateBtn.disabled = !1, e.length > 0 && (generateBtn.classList.remove("hidden"), resetBtn.classList.remove("hidden"), downloadAllBtn.style.cssText = "background: linear-gradient(90deg, #52527a, transparent); border:none; box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: #fff", downloadAllBtn.textContent = "Ready to generate!"))
}

function isValidGmail(e) {
    const t = e.trim().toLowerCase();
    if (!t.includes("@gmail.com")) return !1;
    if (1 !== (t.match(/@gmail\.com/g) || []).length || !t.endsWith("@gmail.com")) return !1;
    const a = t.split("@gmail.com")[0];
    return !!/^[a-zA-Z0-9]+$/.test(a)
}

function updateLineNumbers() {
    const e = emailsInput.value.split("\n");
    let t = "";
    for (let a = 1; a <= Math.max(1, e.length); a++) t += a + "<br>";
    lineNumbers.innerHTML = t
}
async function initDotTrick() {
    emailsInput.value = "", await emailsInput.addEventListener("input", handleInputValue), await handleInputValue()
}
async function createWorker() {
    if (!accessToken) return void console.error("Unauthorized");
    const e = cacheUtils.get("worker_code");
    if (e) {
        const t = new Blob([e], {
            type: "application/javascript"
        });
        cachedWorkerCode = URL.createObjectURL(t)
    } else if (!cachedWorkerCode) {
        const e = await fetch(`${SERVER_URL}/wc`, {
            headers: {
                Authorization: `Bearer ${accessToken}`
            }
        });
        if (!e.ok) throw new Error("Failed to load worker code");
        const t = await e.text();
        cacheUtils.set("worker_code", t);
        const a = new Blob([t], {
            type: "application/javascript"
        });
        cachedWorkerCode = URL.createObjectURL(a)
    }
    const t = new Worker(cachedWorkerCode);
    return t.onmessage = function(e) {
        const {
            type: t,
            data: a
        } = e.data;
        switch (t) {
            case "chunk":
                processWorkerChunk(a);
                break;
            case "error":
                handleWorkerError(a.email, a.message)
        }
    }, t.onerror = function(e) {
        let a = null;
        for (let [e, n] of activeWorkers)
            if (n === t) {
                a = e;
                break
            } handleWorkerError(a, "Worker error: " + e.message)
    }, t
}

function processWorkerChunk(e) {
    if (!accessToken) return void console.error("Unauthorized");
    const {
        combinations: t,
        total: a,
        chunk: n,
        hasMore: s,
        email: o
    } = e, l = emailTasks.get(o);
    if (!l) {
        const e = activeWorkers.get(o);
        return void(e && e.terminate())
    }
    l.combinations = [...l.combinations, ...t], l.totalCombinations = a, l.processedCount = l.combinations.length;
    const i = Math.min(100, Math.round(l.processedCount / a * 100));
    l.progressBar.style.width = i + "%", l.progressBar.textContent = i + "%";
    const r = (Date.now() - l.startTime) / 1e3,
        d = Math.round(l.processedCount / r);
    l.details.innerHTML = `<div>Generated: ${l.processedCount}/${a}</div><div>Speed: ${d}/sec</div>`, s && isProcessing && "processing" === l.status ? setTimeout((() => {
        isProcessing && emailTasks.has(o) && activeWorkers.has(o) && activeWorkers.get(o).postMessage({
            type: "generate",
            data: {
                email: o,
                chunk: n + 1,
                limit: CHUNK_LIMIT
            }
        })
    }), 1) : finishEmailTask(o), updateGlobalProgress()
}
async function handleWorkerError(e, t) {
    appConfig || (appConfig = await getConfig());
    const a = appConfig.nextTaskDelay,
        n = emailTasks.get(e),
        s = activeWorkers.get(e);
    n ? (n.status = "error", n.details.textContent = "Error: " + t, n.progressBar.style.background = "#ff4d4d", n.element.classList.remove("active-task"), s && (s.terminate(), activeWorkers.delete(e)), currentProcessingBatch.delete(e), completedTasks++, updateGlobalProgress(), 0 === currentProcessingBatch.size && isBatchCurrentlyActive && (isBatchCurrentlyActive = !1, currentEmailQueueIndex < emailQueue.length && setTimeout(startNextBatch, a))) : s && s.terminate()
}

function createEmailTask(e, t) {
    if (!accessToken) return void console.error("Unauthorized");
    const a = document.createElement("div");
    a.className = "email-task", taskHtml = appConfig.taskHtml, a.innerHTML = `<div class="email-header"><div class="task-number">${t}</div><div class="email-address">${e}</div></div><div class="email-progress"><div class="progress-bar-container"><div class="progress-bar">0</div></div></div><div class="task-actions"><div class="email-details">Generated:0/0</div><button class="download-btn" disabled><i class="fa-solid fa-download"></i> Download</button></div>`;
    const n = {
        element: a,
        email: e,
        combinations: [],
        totalCombinations: 0,
        processedCount: 0,
        status: "pending",
        startTime: Date.now(),
        progressBar: a.querySelector(".progress-bar"),
        details: a.querySelector(".email-details"),
        downloadBtn: a.querySelector(".download-btn")
    };
    return n.downloadBtn.addEventListener("click", (() => {
        downloadEmailResults(e), n.downloadBtn.disabled = !0, n.downloadBtn.innerHTML = '<i class="fa-solid fa-check"></i> Downloaded'
    })), emailTasks.set(e, n), emailTasksContainer.appendChild(a), n
}
async function startNextBatch() {
    if (!isProcessing || isBatchCurrentlyActive || currentEmailQueueIndex >= emailQueue.length) return;
    isBatchCurrentlyActive = !0, currentProcessingBatch.clear();
    const e = emailTasks.get(emailQueue[currentEmailQueueIndex])?.element;
    e && setTimeout((() => {
        e.scrollIntoView({
            behavior: "smooth",
            block: "start"
        })
    }), 50);
    let t = 0;
    for (; t < MAX_CONCURRENT_TASKS && currentEmailQueueIndex < emailQueue.length;) {
        const e = emailQueue[currentEmailQueueIndex],
            a = emailTasks.get(e);
        if (a && "pending" === a.status) {
            a.status = "processing", a.startTime = Date.now(), a.element.classList.add("active-task");
            const n = await createWorker();
            activeWorkers.set(e, n), currentProcessingBatch.add(e), n.postMessage({
                type: "generate",
                data: {
                    email: e,
                    chunk: 0,
                    limit: CHUNK_LIMIT
                }
            }), t++
        }
        currentEmailQueueIndex++
    }
    updateGlobalProgress()
}
async function finishEmailTask(e) {
    if (!accessToken) return void console.error("Unauthorized");
    appConfig || (appConfig = await getConfig());
    const t = appConfig.nextTaskDelay,
        a = emailTasks.get(e),
        n = activeWorkers.get(e);
        
    if (a) {
        // Simpan hasil ke IndexedDB sebelum melanjutkan
        try {
            await saveToIndexedDB(e, a.combinations);
            // Hapus kombinasi dari memori untuk menghemat ruang
            a.combinations = [];
        } catch (error) {
            console.error("IndexedDB:", error);
        }
        
        a.status = "completed";
        a.details.style.color = "#66ffd9";
        a.details.textContent = `Generated: ${a.processedCount}/${a.totalCombinations} emails`;
        a.downloadBtn.disabled = !1;
        a.element.classList.remove("active-task");
        n && (n.terminate(), activeWorkers.delete(e));
        currentProcessingBatch.delete(e);
        completedTasks++;
        updateGlobalProgress();
        
        if (0 === currentProcessingBatch.size && isBatchCurrentlyActive) {
            isBatchCurrentlyActive = !1;
            currentEmailQueueIndex < emailQueue.length && setTimeout(startNextBatch, t);
        }
    }
}

function updateGlobalProgress() {
    if (!accessToken) return void console.error("Unauthorized");
    if (0 === totalTasks) return void(globalProgress.textContent = "");
    const e = Math.round(completedTasks / totalTasks * 100);
    globalProgress.textContent = `Overall Progress: ${completedTasks}/${totalTasks} emails completed (${e}%)`, completedTasks === totalTasks && (isProcessing = !1, globalProgress.style.color = "#fff", generateBtn.style.cssText = "", generateBtn.classList.add("hidden"), globalProgress.textContent = `All tasks completed! Generated ${completedTasks} of ${totalTasks} emails.`, downloadAllBtn.innerHTML = '<i class="fa-solid fa-file-zipper"></i> Zip all files and download!', downloadAllBtn.style.cssText = "", resetBtn.disabled = !1, resetBtn.style.cssText = "background: linear-gradient(90deg, #8080ff, #e6e6ff); border: 2px solid #ccccff; box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.5); color: white", downloadAllBtn.disabled = !1)
}

function saveAs(e, t) {
    if (!accessToken) return void console.error("Unauthorized");
    const a = document.createElement("a");
    a.href = URL.createObjectURL(e), a.download = t, document.body.appendChild(a), a.click(), document.body.removeChild(a), URL.revokeObjectURL(a.href)
}
async function downloadEmailResults(e) {
    if (!accessToken) return void console.error("Unauthorized");
    appConfig || (appConfig = await getConfig());
    
    // Ambil data dari IndexedDB
    const data = await getFromIndexedDB(e);
    if (!data || !data.combinations || data.combinations.length === 0) {
        alert('Tidak ada data untuk ' + e);
        return;
    }
    
    const a = data.combinations.join("\n");
    saveAs(new Blob([a], {
        type: "text/plain"
    }), e + appConfig.singleDownloadFilename)
}

async function downloadAllResults() {
    if (0 === completedTasks) return;
    if (!accessToken) return void console.error("Unauthorized");
    
    const e = document.querySelectorAll(".download-btn");
    appConfig || (appConfig = await getConfig());
	globalProgress.textContent = `Creating ZIP archive: 0%`;
	globalProgress.style.cssText="font-size: 1rem; color: #ffff00 ";	
    downloadAllBtn.textContent = "Preparing for download...";
    downloadAllBtn.disabled = !0;
    resetBtn.disabled = !0;
    e.forEach((e => {
        e.disabled = !0
    }));
    
    // Ambil semua data dari IndexedDB
    const allData = await getAllFromIndexedDB();
    if (0 === allData.length) return alert("No completed email data to download."), resetBtn.disabled = !1, downloadAllBtn.disabled = !1, downloadAllBtn.innerHTML = '<i class="fa-solid fa-file-zipper"></i> Download all as ZIP!', void(downloadAllBtn.style.color = "#fff");
    
    try {
        const t = new JSZip,
            a = appConfig.allDownloadFilename;
        let n = 0;
        
        for (const data of allData) {
            if (data.combinations.length > 0) {
                const o = data.email + a,
                    l = data.combinations.join("\n");
                t.file(o, l), n++
            }
        }
        
        const b = appConfig.downloadType,
            s = appConfig.downloadCompression,
            o = appConfig.downloadCompressionOptions,
            l = await t.generateAsync({
                type: b,
                compression: s,
                compressionOptions: o
            }, (function(e) {
                let t = e.percent.toFixed(2);
				downloadAllBtn.innerHTML = `<div>Processing download <span style="color:#00ffff">${n}</span> emails...</div><div style="color: #ff3300; text-shadow: 1px #000; font-weight:900"><i class="fa-regular fa-clock" style="color:#fff"></i> This process may take a few minutes!</div>`;
				downloadAllBtn.style.cssText="display: flex; flex-direction: column; gap: 5px; background: rgba(0, 0, 0, 0.7); box-shadow: 0 0 10px 2px rgba(255, 62, 79, 0.); color: #fff; padding: 5px; font-size: 0.8rem; ";
                globalProgress.textContent = `Creating ZIP archive: ${t}%`
            })),
            i = new Date;
            
        e.forEach((e => {
            e.innerHTML = '<i class="fa-solid fa-check"></i> Downloaded'
        }));
        
        // Hapus semua data dari IndexedDB setelah berhasil membuat ZIP
        await clearAllIndexedDB();
        
        saveAs(l, `${n}-Gmail_Dot_Tricks-${i.toLocaleDateString()+"-"+i.toLocaleTimeString()}.zip`);
        resetBtn.disabled = !1;
        globalProgress.textContent = "";
		globalProgress.style.cssText="";
		downloadAllBtn.style.cssText="";
        downloadAllBtn.style.color = "#fff";
        downloadAllBtn.innerHTML = `<span style="color:#00ffff">${n}</span> emails successfully downloaded!`
    } catch (t) {
        console.error("Error creating ZIP file:", t);
        downloadAllBtn.textContent = "Error creating ZIP file. Please try again.";
        downloadAllBtn.disabled = !1
    }
}
generateBtn.addEventListener("click", (async function() {
    if (isProcessing) return;
    generateBtn.disabled = !0, resetBtn.disabled = !0;
    const e = emailsInput.value.split("\n").map((e => e.trim())).filter((e => e.length > 0));
    if (0 !== e.length) {
        appConfig || (appConfig = await getConfig()), MAX_CONCURRENT_TASKS = window.innerWidth >= 1024 ? appConfig.maxConcurrentTasksDesktop : appConfig.maxConcurrentTasksMobile, CHUNK_LIMIT = appConfig.chunkLimit, emailTasks.clear();
        for (let e of activeWorkers.values()) e.terminate();
        activeWorkers.clear(), emailsInput.readOnly = !0, generateBtn.classList.add("hidden"), outputInfo.classList.add("hidden"), emailTasksContainer.classList.remove("hidden"), currentProcessingBatch.clear(), isBatchCurrentlyActive = !1, completedTasks = 0, totalTasks = e.length, currentEmailQueueIndex = 0, isProcessing = !0, downloadAllBtn.disabled = !0, downloadAllBtn.textContent = "Generating...", globalProgress.textContent = `Starting ${totalTasks}email tasks...`, emailQueue = [], e.forEach(((e, t) => {
            createEmailTask(e, t + 1), emailQueue.push(e)
        })), startNextBatch(), updateGlobalProgress()
    } else alert("Please enter at least one email!")
})), resetBtn.addEventListener("click", (async function() {
    isProcessing = !1;
    for (let e of activeWorkers.values()) e.terminate();
    activeWorkers.clear(), emailTasks.clear(), emailQueue = [], currentProcessingBatch.clear(), isBatchCurrentlyActive = !1, resetBtn.style.cssText = "", generateBtn.textContent = "Generate", globalProgress.style.color = "#ff0", emailTasksContainer.innerHTML = "", emailTasksContainer.classList.add("hidden"), outputInfo.classList.remove("hidden"), emailsInput.readOnly = !1, emailsInput.value = "", completedTasks = 0, totalTasks = 0, currentEmailQueueIndex = 0, updateLineNumbers(), generateBtn.classList.remove("hidden"), generateBtn.disabled = !1, downloadAllBtn.disabled = !0, downloadAllBtn.innerHTML = '<i class="fa-solid fa-file-zipper"></i> Download all as zip!', globalProgress.textContent = "", await initDotTrick(), await clearAllIndexedDB()
})), downloadAllBtn.addEventListener("click", downloadAllResults), updateLineNumbers(), emailsInput.addEventListener("scroll", (function() {
    lineNumbers.scrollTop = this.scrollTop
})), removeDuplicatesBtn.addEventListener("click", (async function() {
    const e = emailsInput.value.split("\n").map((e => e.trim())).filter((e => e.length > 0)),
        t = new Set,
        a = [];
    e.forEach((e => {
        if (e.toLowerCase().includes("@gmail.com")) {
            const n = e.toLowerCase().replace(/\./g, "").split("+")[0];
            t.has(n) || (t.add(n), a.push(e))
        } else a.push(e)
    })), emailsInput.value = a.join("\n"), await handleInputValue(), await checkInvalidEmails(), outputInfo.classList.remove("hidden"), errorEmailOverlay.classList.add("hidden"), removeDuplicatesBtn.classList.add("hidden")
})), removeInvalidBtn.addEventListener("click", (async function() {
    const e = emailsInput.value.split("\n").map((e => e.trim())).filter((e => e.length > 0)),
        t = /^[^\s@]+@gmail\.com$/i,
        a = e.filter((e => t.test(e)));
    emailsInput.value = a.join("\n"), await handleInputValue(), await checkDuplicates(), outputInfo.classList.remove("hidden"), errorEmailOverlay.classList.add("hidden"), removeInvalidBtn.classList.add("hidden")
})), initDotTrick();

(async function init() {
    try {
        await openDatabase();
		await clearAllIndexedDB();
        await cleanupExpiredData();
    } catch (error) {
        console.error("Gagal inisialisasi database:", error);
    }
})();
		</script>
	</body>
</html>